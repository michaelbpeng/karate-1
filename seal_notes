Here's a complete example of the Spring Boot batch project with the described flow, using Java 17, Lombok, and PostgreSQL. This example includes the necessary configurations, components, and SQL schema.

### 1. **SQL Schema**

Create the schema for the PostgreSQL database:

```sql
-- Sequence for generating summary_id
CREATE SEQUENCE summary_id_seq START 1;

-- Table to hold daily order summaries
CREATE TABLE DailyOrderSummary (
    summary_id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    total_orders INT,
    total_amount DECIMAL(10, 2)
);

-- Table to map daily summaries to purchase orders
CREATE TABLE DailyOrderSummary_PurchaseOrder (
    summary_id BIGINT,
    purchase_order_id BIGINT,
    PRIMARY KEY (summary_id, purchase_order_id),
    FOREIGN KEY (summary_id) REFERENCES DailyOrderSummary (summary_id),
    FOREIGN KEY (purchase_order_id) REFERENCES PurchaseOrder (id)
);
```

### 2. **Project Structure**

Here’s the structure of the project:

```
src
└── main
    ├── java
    │   └── com
    │       └── example
    │           └── batch
    │               ├── BatchConfiguration.java
    │               ├── JobStartListener.java
    │               ├── PurchaseOrderProcessor.java
    │               ├── PurchaseOrderItemWriter.java
    │               ├── PurchaseOrder.java
    │               └── Application.java
    └── resources
        └── application.properties
```

### 3. **Application Configuration**

**`application.properties`**

```properties
spring.datasource.url=jdbc:postgresql://localhost:5432/yourdatabase
spring.datasource.username=yourusername
spring.datasource.password=yourpassword
spring.jpa.hibernate.ddl-auto=none
spring.batch.job.enabled=false
```

### 4. **Java Classes**

**`BatchConfiguration.java`**

```java
package com.example.batch;

import org.springframework.batch.core.Job;
import org.springframework.batch.core.Step;
import org.springframework.batch.core.configuration.annotation.EnableBatchProcessing;
import org.springframework.batch.core.configuration.annotation.JobBuilderFactory;
import org.springframework.batch.core.configuration.annotation.StepBuilderFactory;
import org.springframework.batch.core.launch.support.RunIdIncrementer;
import org.springframework.batch.core.step.builder.StepBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.task.SimpleAsyncTaskExecutor;
import org.springframework.core.task.TaskExecutor;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import org.springframework.transaction.PlatformTransactionManager;

import javax.sql.DataSource;

@Configuration
@EnableBatchProcessing
public class BatchConfiguration {

    private final JobBuilderFactory jobBuilderFactory;
    private final StepBuilderFactory stepBuilderFactory;
    private final DataSource dataSource;
    private final JdbcTemplate jdbcTemplate;

    public BatchConfiguration(JobBuilderFactory jobBuilderFactory, StepBuilderFactory stepBuilderFactory, DataSource dataSource, JdbcTemplate jdbcTemplate) {
        this.jobBuilderFactory = jobBuilderFactory;
        this.stepBuilderFactory = stepBuilderFactory;
        this.dataSource = dataSource;
        this.jdbcTemplate = jdbcTemplate;
    }

    @Bean
    public PlatformTransactionManager transactionManager() {
        return new DataSourceTransactionManager(dataSource);
    }

    @Bean
    public TaskExecutor taskExecutor() {
        return new SimpleAsyncTaskExecutor("spring_batch");
    }

    @Bean
    public Job rollupJob(JobStartListener listener, Step processStep, Step writeStep) {
        return jobBuilderFactory.get("rollupJob")
                .incrementer(new RunIdIncrementer())
                .listener(listener)
                .start(processStep)
                .next(writeStep)
                .build();
    }

    @Bean
    public Step processStep() {
        return stepBuilderFactory.get("processStep")
                .<PurchaseOrder, PurchaseOrder>chunk(1000)
                .processor(new PurchaseOrderProcessor(jdbcTemplate, transactionManager(), new StepExecution()))
                .build();
    }

    @Bean
    public Step writeStep() {
        return stepBuilderFactory.get("writeStep")
                .<PurchaseOrder, PurchaseOrder>chunk(1000)
                .writer(new PurchaseOrderItemWriter("outputFile.txt", jdbcTemplate, transactionManager(), new StepExecution()))
                .build();
    }
}
```

**`JobStartListener.java`**

```java
package com.example.batch;

import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.JobExecutionListener;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.DefaultTransactionDefinition;

@Component
public class JobStartListener implements JobExecutionListener {

    private final JdbcTemplate jdbcTemplate;
    private final PlatformTransactionManager transactionManager;

    public JobStartListener(JdbcTemplate jdbcTemplate, PlatformTransactionManager transactionManager) {
        this.jdbcTemplate = jdbcTemplate;
        this.transactionManager = transactionManager;
    }

    @Override
    public void beforeJob(JobExecution jobExecution) {
        DefaultTransactionDefinition def = new DefaultTransactionDefinition();
        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
        TransactionStatus status = transactionManager.getTransaction(def);

        try {
            // Insert a new summary entry and return the generated summary_id
            Long summaryId = jdbcTemplate.queryForObject(
                "INSERT INTO DailyOrderSummary (total_orders, total_amount) VALUES (0, 0) " +
                "RETURNING summary_id", 
                Long.class
            );

            // Store summary_id in the job execution context
            jobExecution.getExecutionContext().put("summaryId", summaryId);

            transactionManager.commit(status);
        } catch (Exception e) {
            transactionManager.rollback(status);
            throw e;
        }
    }

    @Override
    public void afterJob(JobExecution jobExecution) {
        // No action required after job execution
    }
}
```

**`PurchaseOrderProcessor.java`**

```java
package com.example.batch;

import lombok.RequiredArgsConstructor;
import org.springframework.batch.item.ItemProcessor;
import org.springframework.batch.core.StepExecution;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.DefaultTransactionDefinition;
import org.springframework.jdbc.core.JdbcTemplate;

@RequiredArgsConstructor
public class PurchaseOrderProcessor implements ItemProcessor<PurchaseOrder, PurchaseOrder> {
    private final JdbcTemplate jdbcTemplate;
    private final PlatformTransactionManager transactionManager;
    private final StepExecution stepExecution;

    @Override
    public PurchaseOrder process(PurchaseOrder purchaseOrder) throws Exception {
        Long summaryId = (Long) stepExecution.getJobExecution().getExecutionContext().get("summaryId");

        // Retrieve and update totals in the step execution context
        Integer totalOrders = stepExecution.getExecutionContext().getInt("totalOrders", 0);
        Double totalAmount = stepExecution.getExecutionContext().getDouble("totalAmount", 0.0);

        totalOrders++;
        totalAmount += purchaseOrder.getTotalAmount();

        stepExecution.getExecutionContext().put("totalOrders", totalOrders);
        stepExecution.getExecutionContext().put("totalAmount", totalAmount);

        // Insert into the mapping table with the correct summaryId
        DefaultTransactionDefinition def = new DefaultTransactionDefinition();
        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
        TransactionStatus status = transactionManager.getTransaction(def);

        try {
            jdbcTemplate.update(
                "INSERT INTO DailyOrderSummary_PurchaseOrder (summary_id, purchase_order_id) VALUES (?, ?)",
                summaryId, purchaseOrder.getId()
            );
            transactionManager.commit(status);
        } catch (Exception e) {
            transactionManager.rollback(status);
            throw e;
        }

        return purchaseOrder;
    }
}
```

**`PurchaseOrderItemWriter.java`**

```java
package com.example.batch;

import lombok.RequiredArgsConstructor;
import org.springframework.batch.item.ItemWriter;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.DefaultTransactionDefinition;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.util.List;

@RequiredArgsConstructor
public class PurchaseOrderItemWriter implements ItemWriter<PurchaseOrder> {
    private final String outputPath;
    private final JdbcTemplate jdbcTemplate;
    private final PlatformTransactionManager transactionManager;
    private final StepExecution stepExecution;

    @Override
    public void write(List<? extends PurchaseOrder> items) throws IOException {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(outputPath, true))) {
            for (PurchaseOrder order : items) {
                writer.write(order.toString()); // Adjust the format as needed
                writer.newLine();
            }

            // Retrieve accumulated totals and summaryId from the step context
            Integer totalOrders = stepExecution.getExecutionContext().getInt("totalOrders", 0);
            Double totalAmount = stepExecution.getExecutionContext().getDouble("totalAmount", 0.0);
            Long summaryId = (Long) stepExecution.getJobExecution().getExecutionContext().get("summaryId");

            // Insert or update summary information
            insertOrUpdateSummary(summaryId, totalOrders, totalAmount);
        }
    }

    private void insertOrUpdateSummary(Long summaryId, int totalOrders, double totalAmount) {
        DefaultTransactionDefinition def = new DefaultTransactionDefinition();
        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
        TransactionStatus status = transactionManager.getTransaction(def);

        try {
            jdbcTemplate.update(
                "INSERT INTO DailyOrderSummary (summary_id, total_orders, total_amount) VALUES (?, ?, ?) " +
                "ON CONFLICT (summary_id) DO UPDATE SET total_orders = excluded.total_orders, total_amount = excluded.total_amount",
               

 summaryId, totalOrders, totalAmount
            );
            transactionManager.commit(status);
        } catch (Exception e) {
            transactionManager.rollback(status);
            throw e;
        }
    }
}
```

**`PurchaseOrder.java`**

```java
package com.example.batch;

import lombok.Data;

@Data
public class PurchaseOrder {
    private Long id;
    private Double totalAmount;
    private String orderDate;

    @Override
    public String toString() {
        return id + "," + totalAmount + "," + orderDate;
    }
}
```

**`Application.java`**

```java
package com.example.batch;

import org.springframework.batch.core.Job;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.JobParameters;
import org.springframework.batch.core.launch.JobLauncher;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class Application implements CommandLineRunner {

    @Autowired
    private JobLauncher jobLauncher;

    @Autowired
    private Job rollupJob;

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

    @Override
    public void run(String... args) throws Exception {
        JobExecution jobExecution = jobLauncher.run(rollupJob, new JobParameters());
        System.out.println("Job Status: " + jobExecution.getStatus());
    }
}
```

### Summary

This project setup includes:

- **SQL Schema**: Defines the tables and sequences needed.
- **Batch Configuration**: Configures the batch job, steps, and transaction management.
- **JobStartListener**: Handles the job start event to create a new summary record and retrieve the `summary_id`.
- **PurchaseOrderProcessor**: Processes purchase orders, updates totals, and maps orders to the summary.
- **PurchaseOrderItemWriter**: Writes orders to a file and updates the summary table.
- **PurchaseOrder**: Represents the purchase order data.
- **Application**: The main entry point for running the batch job.






------------
package com.example.batch;

import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.JobExecutionListener;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.DefaultTransactionDefinition;

@Component
public class JobStartListener implements JobExecutionListener {

    private final JdbcTemplate jdbcTemplate;
    private final PlatformTransactionManager transactionManager;

    public JobStartListener(JdbcTemplate jdbcTemplate, PlatformTransactionManager transactionManager) {
        this.jdbcTemplate = jdbcTemplate;
        this.transactionManager = transactionManager;
    }

    @Override
    public void beforeJob(JobExecution jobExecution) {
        DefaultTransactionDefinition def = new DefaultTransactionDefinition();
        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
        TransactionStatus status = transactionManager.getTransaction(def);

        try {
            // Generate a new summary_id
            Long summaryId = jdbcTemplate.queryForObject("SELECT nextval('summary_id_seq')", Long.class);

            // Insert the summary_id into DailyOrderSummary with default values
            jdbcTemplate.update(
                "INSERT INTO DailyOrderSummary (summary_id, total_orders, total_amount) VALUES (?, 0, 0) " +
                "ON CONFLICT (summary_id) DO NOTHING",
                summaryId
            );

            // Store summary_id in the job execution context
            jobExecution.getExecutionContext().put("summaryId", summaryId);

            transactionManager.commit(status);
        } catch (Exception e) {
            transactionManager.rollback(status);
            throw e;
        }
    }

    @Override
    public void afterJob(JobExecution jobExecution) {
        // No action required after job execution
    }
}

——————————

You can now build and run this project using Maven or Gradle. Make sure to replace placeholders in `application.properties` with your actual database credentials.



---
package com.example.batch;

import lombok.RequiredArgsConstructor;
import org.springframework.batch.item.ItemWriter;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.DefaultTransactionDefinition;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.util.List;

@RequiredArgsConstructor
public class PurchaseOrderItemWriter implements ItemWriter<PurchaseOrder> {
    private final String outputPath;
    private final JdbcTemplate jdbcTemplate;
    private final PlatformTransactionManager transactionManager;
    private final StepExecution stepExecution;

    @Override
    public void write(List<? extends PurchaseOrder> items) throws IOException {
        DefaultTransactionDefinition def = new DefaultTransactionDefinition();
        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
        TransactionStatus status = transactionManager.getTransaction(def);

        try (BufferedWriter writer = new BufferedWriter(new FileWriter(outputPath, true))) {
            for (PurchaseOrder order : items) {
                writer.write(order.toString()); // Adjust the format as needed
                writer.newLine();
            }

            // Perform bulk insert into the mapping table
            Long summaryId = (Long) stepExecution.getJobExecution().getExecutionContext().get("summaryId");
            String sql = "INSERT INTO DailyOrderSummary_PurchaseOrder (summary_id, purchase_order_id) VALUES (?, ?)";

            jdbcTemplate.batchUpdate(sql, items, items.size(), (ps, purchaseOrder) -> {
                ps.setLong(1, summaryId);
                ps.setLong(2, purchaseOrder.getId());
            });

            // Retrieve accumulated totals and update the summary table
            Integer totalOrders = stepExecution.getExecutionContext().getInt("totalOrders", 0);
            Double totalAmount = stepExecution.getExecutionContext().getDouble("totalAmount", 0.0);

            insertOrUpdateSummary(summaryId, totalOrders, totalAmount);

            transactionManager.commit(status);
        } catch (Exception e) {
            transactionManager.rollback(status);
            throw e;
        }
    }

    private void insertOrUpdateSummary(Long summaryId, int totalOrders, double totalAmount) {
        jdbcTemplate.update(
            "INSERT INTO DailyOrderSummary (summary_id, total_orders, total_amount) VALUES (?, ?, ?) " +
            "ON CONFLICT (summary_id) DO UPDATE SET total_orders = excluded.total_orders, total_amount = excluded.total_amount",
            summaryId, totalOrders, totalAmount
        );
    }
}




------------
Let's revert to using YAML for externalizing SQL queries. Here's how you can adjust the project to load SQL queries from a YAML file.

### 1. **Create a YAML Configuration File**

Create a YAML configuration file, e.g., `sql-queries.yml`, in the `src/main/resources` directory.

**`sql-queries.yml`**:

```yaml
purchaseOrder:
  insertMapping: "INSERT INTO DailyOrderSummary_PurchaseOrder (summary_id, purchase_order_id) VALUES (?, ?)"
  insertOrUpdateSummary: |
    INSERT INTO DailyOrderSummary (summary_id, total_orders, total_amount) VALUES (?, ?, ?)
    ON CONFLICT (summary_id) DO UPDATE SET total_orders = excluded.total_orders, total_amount = excluded.total_amount
```

### 2. **Load Queries from the YAML File**

You can use the `@ConfigurationProperties` annotation to load the properties from the YAML file.

**`SqlQueriesConfig.java`**:

```java
package com.example.batch;

import lombok.Getter;
import lombok.Setter;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

@Configuration
@ConfigurationProperties(prefix = "purchaseOrder")
@Getter
@Setter
public class SqlQueriesConfig {
    private String insertMapping;
    private String insertOrUpdateSummary;
}
```

### 3. **Configure `application.yml` to Import `sql-queries.yml`**

Ensure that Spring Boot is aware of your `sql-queries.yml` file by importing it in your `application.yml`.

**`application.yml`**:

```yaml
spring:
  config:
    import: "classpath:sql-queries.yml"
```

### 4. **Inject the Queries into `PurchaseOrderItemWriter`**

Now, you can inject the `SqlQueriesConfig` bean into your `PurchaseOrderItemWriter` and use the loaded queries.

**`PurchaseOrderItemWriter.java`**:

```java
package com.example.batch;

import lombok.RequiredArgsConstructor;
import org.springframework.batch.item.ItemWriter;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.DefaultTransactionDefinition;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.util.List;

@RequiredArgsConstructor
public class PurchaseOrderItemWriter implements ItemWriter<PurchaseOrder> {
    private final String outputPath;
    private final JdbcTemplate jdbcTemplate;
    private final PlatformTransactionManager transactionManager;
    private final StepExecution stepExecution;
    private final SqlQueriesConfig sqlQueriesConfig;

    @Override
    public void write(List<? extends PurchaseOrder> items) throws IOException {
        DefaultTransactionDefinition def = new DefaultTransactionDefinition();
        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
        TransactionStatus status = transactionManager.getTransaction(def);

        try (BufferedWriter writer = new BufferedWriter(new FileWriter(outputPath, true))) {
            for (PurchaseOrder order : items) {
                writer.write(order.toString()); // Adjust the format as needed
                writer.newLine();
            }

            // Perform bulk insert into the mapping table using externalized query
            Long summaryId = (Long) stepExecution.getJobExecution().getExecutionContext().get("summaryId");
            String insertMappingQuery = sqlQueriesConfig.getInsertMapping();

            jdbcTemplate.batchUpdate(insertMappingQuery, items, items.size(), (ps, purchaseOrder) -> {
                ps.setLong(1, summaryId);
                ps.setLong(2, purchaseOrder.getId());
            });

            // Retrieve accumulated totals and update the summary table using externalized query
            Integer totalOrders = stepExecution.getExecutionContext().getInt("totalOrders", 0);
            Double totalAmount = stepExecution.getExecutionContext().getDouble("totalAmount", 0.0);
            String insertOrUpdateSummaryQuery = sqlQueriesConfig.getInsertOrUpdateSummary();

            insertOrUpdateSummary(summaryId, totalOrders, totalAmount, insertOrUpdateSummaryQuery);

            transactionManager.commit(status);
        } catch (Exception e) {
            transactionManager.rollback(status);
            throw e;
        }
    }

    private void insertOrUpdateSummary(Long summaryId, int totalOrders, double totalAmount, String query) {
        jdbcTemplate.update(query, summaryId, totalOrders, totalAmount);
    }
}
```

### Summary

- **Externalized Queries**: SQL queries are now stored in `sql-queries.yml`.
- **Configuration Class**: The `SqlQueriesConfig` class is used to load and provide these queries to the writer.
- **Usage**: The `PurchaseOrderItemWriter` class reads the queries from the configuration and uses them in the batch processing logic.

This setup allows you to manage your SQL queries easily from a YAML file, making it easier to update and maintain without altering the codebase.


---------
timestamp with tz
package com.example.batch.reader;

import com.example.batch.model.PurchaseOrder;
import com.example.batch.config.SqlQueriesConfig;
import com.example.batch.rowmapper.PurchaseOrderRowMapper;
import lombok.RequiredArgsConstructor;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.configuration.annotation.StepScope;
import org.springframework.batch.core.scope.context.StepContext;
import org.springframework.batch.core.scope.context.StepSynchronizationManager;
import org.springframework.batch.item.database.JdbcCursorItemReader;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;

import javax.sql.DataSource;
import java.util.Date;

@Configuration
@RequiredArgsConstructor
public class PurchaseOrderItemReader {

    private final DataSource dataSource;
    private final SqlQueriesConfig sqlQueriesConfig;

    @Bean
    @StepScope
    public JdbcCursorItemReader<PurchaseOrder> reader() {
        JdbcCursorItemReader<PurchaseOrder> reader = new JdbcCursorItemReader<>();

        StepContext stepContext = StepSynchronizationManager.getContext();
        JobExecution jobExecution = stepContext.getStepExecution().getJobExecution();

        reader.setDataSource(dataSource);
        reader.setSql(sqlQueriesConfig.getSelectOrders());
        reader.setRowMapper(new PurchaseOrderRowMapper());

        // Retrieve the order timestamp and timezone from job parameters
        Date orderTimestamp = jobExecution.getJobParameters().getDate("orderTimestamp");
        String timeZone = jobExecution.getJobParameters().getString("timeZone");

        // Bind the timestamp and timezone parameters to the query
        NamedParameterJdbcTemplate namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);
        MapSqlParameterSource parameters = new MapSqlParameterSource();
        parameters.addValue("orderTimestamp", orderTimestamp);
        parameters.addValue("timeZone", timeZone);

        reader.setPreparedStatementSetter(ps -> {
            ps.setTimestamp(1, new java.sql.Timestamp(orderTimestamp.getTime()));
            ps.setString(2, timeZone);
        });

        return reader;
    }
}



purchaseOrder:
  insertMapping: "INSERT INTO DailyOrderSummary_PurchaseOrder (summary_id, purchase_order_id) VALUES (?, ?)"
  insertOrUpdateSummary: |
    INSERT INTO DailyOrderSummary (summary_id, total_orders, total_amount) VALUES (?, ?, ?)
    ON CONFLICT (summary_id) DO UPDATE SET total_orders = excluded.total_orders, total_amount = excluded.total_amount
  selectOrders: |
    SELECT id, description, amount 
    FROM PurchaseOrder 
    WHERE order_timestamp >= (DATE_TRUNC('day', :orderTimestamp AT TIME ZONE :timeZone) AT TIME ZONE :timeZone)
    AND order_timestamp < ((DATE_TRUNC('day', :orderTimestamp AT TIME ZONE :timeZone) + INTERVAL '1 day') AT TIME ZONE :timeZone)




'America/New_York'

spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/yourdatabase
    username: yourusername
    password: yourpassword
    driver-class-name: org.postgresql.Driver
  batch:
    initialize-schema: always
  sql:
    script-encoding: UTF-8
    separator: ";"
  default:
    time-zone: America/New_York



purchaseOrder:
  insertMapping: "INSERT INTO DailyOrderSummary_PurchaseOrder (summary_id, purchase_order_id) VALUES (?, ?)"
  insertOrUpdateSummary: |
    INSERT INTO DailyOrderSummary (summary_id, total_orders, total_amount) VALUES (?, ?, ?)
    ON CONFLICT (summary_id) DO UPDATE SET total_orders = excluded.total_orders, total_amount = excluded.total_amount
  selectOrders: |
    SELECT id, description, amount 
    FROM PurchaseOrder 
    WHERE order_timestamp >= DATE_TRUNC('day', CURRENT_TIMESTAMP AT TIME ZONE 'America/New_York')
    AND order_timestamp < DATE_TRUNC('day', CURRENT_TIMESTAMP AT TIME ZONE 'America/New_York') + INTERVAL '1 day'

package com.example.batch.reader;

import com.example.batch.model.PurchaseOrder;
import com.example.batch.config.SqlQueriesConfig;
import com.example.batch.rowmapper.PurchaseOrderRowMapper;
import lombok.RequiredArgsConstructor;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.configuration.annotation.StepScope;
import org.springframework.batch.core.scope.context.StepContext;
import org.springframework.batch.core.scope.context.StepSynchronizationManager;
import org.springframework.batch.item.database.JdbcCursorItemReader;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;

import javax.sql.DataSource;
import java.util.Date;

@Configuration
@RequiredArgsConstructor
public class PurchaseOrderItemReader {

    private final DataSource dataSource;
    private final SqlQueriesConfig sqlQueriesConfig;

    @Bean
    @StepScope
    public JdbcCursorItemReader<PurchaseOrder> reader() {
        JdbcCursorItemReader<PurchaseOrder> reader = new JdbcCursorItemReader<>();

        StepContext stepContext = StepSynchronizationManager.getContext();
        JobExecution jobExecution = stepContext.getStepExecution().getJobExecution();

        reader.setDataSource(dataSource);
        reader.setSql(sqlQueriesConfig.getSelectOrders());
        reader.setRowMapper(new PurchaseOrderRowMapper());

        // Retrieve the order timestamp from job parameters
        Date orderTimestamp = jobExecution.getJobParameters().getDate("orderTimestamp");

        // Bind the timestamp parameter to the query
        NamedParameterJdbcTemplate namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);
        MapSqlParameterSource parameters = new MapSqlParameterSource();
        parameters.addValue("orderTimestamp", orderTimestamp);

        reader.setPreparedStatementSetter(ps -> {
            ps.setTimestamp(1, new java.sql.Timestamp(orderTimestamp.getTime()));
        });

        return reader;
    }
}



package com.example.batch.writer;

import com.example.batch.config.SqlQueriesConfig;
import com.example.batch.model.PurchaseOrder;
import lombok.RequiredArgsConstructor;
import org.springframework.batch.item.ItemWriter;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.transaction.annotation.Transactional;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@RequiredArgsConstructor
public class PurchaseOrderItemWriter implements ItemWriter<PurchaseOrder> {

    private final String outputPath;
    private final NamedParameterJdbcTemplate namedParameterJdbcTemplate;
    private final SqlQueriesConfig sqlQueriesConfig;

    @Override
    @Transactional
    public void write(List<? extends PurchaseOrder> items) throws IOException {
        // Write purchase orders to the file
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(outputPath, true))) {
            for (PurchaseOrder item : items) {
                writer.write(item.toString());
                writer.newLine();
            }
        }

        // Retrieve summaryId from the context (assuming it's set somewhere else in the job execution context)
        Integer summaryId = getSummaryIdFromContext(); // Replace with actual method to retrieve summaryId

        // Prepare parameters for batch insert
        List<Map<String, Object>> batchValues = items.stream()
            .map(order -> Map.of(
                "summaryId", summaryId,
                "purchaseOrderId", order.getId()
            ))
            .collect(Collectors.toList());

        // Insert into DailyOrderSummary_PurchaseOrder table
        namedParameterJdbcTemplate.batchUpdate(sqlQueriesConfig.getInsertMapping(), batchValues);

        // Calculate total orders and total amount
        BigDecimal totalAmount = items.stream()
            .map(PurchaseOrder::getAmount)
            .reduce(BigDecimal.ZERO, BigDecimal::add);

        Map<String, Object> summaryValues = Map.of(
            "summaryId", summaryId,
            "totalOrders", items.size(),
            "totalAmount", totalAmount
        );

        // Insert or update DailyOrderSummary table
        namedParameterJdbcTemplate.update(sqlQueriesConfig.getInsertOrUpdateSummary(), summaryValues);
    }

    // Dummy method to retrieve summaryId from context; replace with actual implementation
    private Integer getSummaryIdFromContext() {
        // Implement logic to retrieve summaryId from job execution context
        return 1; // Placeholder
    }
}




=======================
Let's set up a simple AOP-based chaos testing framework for your Spring Boot application without using Gremlin, focusing on simulating common chaos scenarios such as inducing delays, throwing exceptions, or modifying responses.

1. Create a Custom Annotation for Chaos Testing
First, define a custom annotation that will mark methods where chaos testing should be applied.

java
Copy code
package com.example.batch.chaos;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface ChaosTest {
    ChaosType value() default ChaosType.NONE;
}

enum ChaosType {
    NONE, DELAY, EXCEPTION, MODIFY_RESPONSE
}
2. Implement the AOP Aspect
Create an AOP aspect that intercepts methods annotated with @ChaosTest and injects chaos based on the specified ChaosType.

java
Copy code
package com.example.batch.chaos;

import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.stereotype.Component;

import java.util.Random;

@Aspect
@Component
@Slf4j
public class ChaosAspect {

    private final Random random = new Random();

    @Around("@annotation(chaosTest)")
    public Object applyChaos(ProceedingJoinPoint joinPoint, ChaosTest chaosTest) throws Throwable {
        switch (chaosTest.value()) {
            case DELAY:
                return induceDelay(joinPoint);
            case EXCEPTION:
                return throwException();
            case MODIFY_RESPONSE:
                return modifyResponse(joinPoint);
            default:
                return joinPoint.proceed();
        }
    }

    private Object induceDelay(ProceedingJoinPoint joinPoint) throws Throwable {
        int delay = random.nextInt(2000) + 500; // Delay between 500ms and 2500ms
        log.info("Inducing a delay of {} ms", delay);
        Thread.sleep(delay);
        return joinPoint.proceed();
    }

    private Object throwException() throws Throwable {
        log.info("Throwing a chaos-induced exception");
        throw new RuntimeException("Chaos-induced exception");
    }

    private Object modifyResponse(ProceedingJoinPoint joinPoint) throws Throwable {
        Object result = joinPoint.proceed();
        if (result instanceof String) {
            log.info("Modifying response due to chaos test");
            return result + " [CHAOS]";
        }
        return result;
    }
}
3. Apply the @ChaosTest Annotation
Use the @ChaosTest annotation on methods where you want to introduce chaos.

java
Copy code
package com.example.batch.job;

import com.example.batch.chaos.ChaosTest;
import com.example.batch.chaos.ChaosType;
import lombok.RequiredArgsConstructor;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.JobExecutionListener;
import org.springframework.batch.core.Step;
import org.springframework.batch.core.configuration.annotation.JobBuilderFactory;
import org.springframework.batch.core.configuration.annotation.StepBuilderFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@RequiredArgsConstructor
public class BatchJobConfig {

    private final JobBuilderFactory jobBuilderFactory;
    private final StepBuilderFactory stepBuilderFactory;

    @Bean
    public Job sampleJob() {
        return jobBuilderFactory.get("sampleJob")
            .start(sampleStep())
            .listener(jobExecutionListener())
            .build();
    }

    @Bean
    public Step sampleStep() {
        return stepBuilderFactory.get("sampleStep")
            .tasklet((contribution, chunkContext) -> {
                executeBusinessLogic();
                return null;
            })
            .build();
    }

    @ChaosTest(ChaosType.DELAY)
    public void executeBusinessLogic() {
        // Your business logic here
        System.out.println("Executing business logic.");
    }

    @Bean
    public JobExecutionListener jobExecutionListener() {
        return new JobExecutionListener() {
            @Override
            public void beforeJob(org.springframework.batch.core.JobExecution jobExecution) {
                // Before job logic
            }

            @Override
            public void afterJob(org.springframework.batch.core.JobExecution jobExecution) {
                // After job logic
            }
        };
    }
}
4. Testing and Monitoring
ChaosType.DELAY: Introduces random delays to simulate latency issues.
ChaosType.EXCEPTION: Throws a runtime exception to test your application's resilience to unexpected failures.
ChaosType.MODIFY_RESPONSE: Modifies the return value of a method to test how your application handles unexpected data changes.
Summary
Custom Annotation: @ChaosTest is used to mark methods where chaos scenarios should be applied.
AOP Aspect: The ChaosAspect class handles the injection of chaos, such as inducing delays, throwing exceptions, or modifying responses.
Application: Annotate methods in your application with @ChaosTest to introduce chaos at specific points.
This AOP-based chaos testing framework allows you to test your application’s robustness and resilience to various failure scenarios without external dependencies like Gremlin.

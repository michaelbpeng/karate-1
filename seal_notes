Here's a complete example of the Spring Boot batch project with the described flow, using Java 17, Lombok, and PostgreSQL. This example includes the necessary configurations, components, and SQL schema.

### 1. **SQL Schema**

Create the schema for the PostgreSQL database:

```sql
-- Sequence for generating summary_id
CREATE SEQUENCE summary_id_seq START 1;

-- Table to hold daily order summaries
CREATE TABLE DailyOrderSummary (
    summary_id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    total_orders INT,
    total_amount DECIMAL(10, 2)
);

-- Table to map daily summaries to purchase orders
CREATE TABLE DailyOrderSummary_PurchaseOrder (
    summary_id BIGINT,
    purchase_order_id BIGINT,
    PRIMARY KEY (summary_id, purchase_order_id),
    FOREIGN KEY (summary_id) REFERENCES DailyOrderSummary (summary_id),
    FOREIGN KEY (purchase_order_id) REFERENCES PurchaseOrder (id)
);
```

### 2. **Project Structure**

Here’s the structure of the project:

```
src
└── main
    ├── java
    │   └── com
    │       └── example
    │           └── batch
    │               ├── BatchConfiguration.java
    │               ├── JobStartListener.java
    │               ├── PurchaseOrderProcessor.java
    │               ├── PurchaseOrderItemWriter.java
    │               ├── PurchaseOrder.java
    │               └── Application.java
    └── resources
        └── application.properties
```

### 3. **Application Configuration**

**`application.properties`**

```properties
spring.datasource.url=jdbc:postgresql://localhost:5432/yourdatabase
spring.datasource.username=yourusername
spring.datasource.password=yourpassword
spring.jpa.hibernate.ddl-auto=none
spring.batch.job.enabled=false
```

### 4. **Java Classes**

**`BatchConfiguration.java`**

```java
package com.example.batch;

import org.springframework.batch.core.Job;
import org.springframework.batch.core.Step;
import org.springframework.batch.core.configuration.annotation.EnableBatchProcessing;
import org.springframework.batch.core.configuration.annotation.JobBuilderFactory;
import org.springframework.batch.core.configuration.annotation.StepBuilderFactory;
import org.springframework.batch.core.launch.support.RunIdIncrementer;
import org.springframework.batch.core.step.builder.StepBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.task.SimpleAsyncTaskExecutor;
import org.springframework.core.task.TaskExecutor;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import org.springframework.transaction.PlatformTransactionManager;

import javax.sql.DataSource;

@Configuration
@EnableBatchProcessing
public class BatchConfiguration {

    private final JobBuilderFactory jobBuilderFactory;
    private final StepBuilderFactory stepBuilderFactory;
    private final DataSource dataSource;
    private final JdbcTemplate jdbcTemplate;

    public BatchConfiguration(JobBuilderFactory jobBuilderFactory, StepBuilderFactory stepBuilderFactory, DataSource dataSource, JdbcTemplate jdbcTemplate) {
        this.jobBuilderFactory = jobBuilderFactory;
        this.stepBuilderFactory = stepBuilderFactory;
        this.dataSource = dataSource;
        this.jdbcTemplate = jdbcTemplate;
    }

    @Bean
    public PlatformTransactionManager transactionManager() {
        return new DataSourceTransactionManager(dataSource);
    }

    @Bean
    public TaskExecutor taskExecutor() {
        return new SimpleAsyncTaskExecutor("spring_batch");
    }

    @Bean
    public Job rollupJob(JobStartListener listener, Step processStep, Step writeStep) {
        return jobBuilderFactory.get("rollupJob")
                .incrementer(new RunIdIncrementer())
                .listener(listener)
                .start(processStep)
                .next(writeStep)
                .build();
    }

    @Bean
    public Step processStep() {
        return stepBuilderFactory.get("processStep")
                .<PurchaseOrder, PurchaseOrder>chunk(1000)
                .processor(new PurchaseOrderProcessor(jdbcTemplate, transactionManager(), new StepExecution()))
                .build();
    }

    @Bean
    public Step writeStep() {
        return stepBuilderFactory.get("writeStep")
                .<PurchaseOrder, PurchaseOrder>chunk(1000)
                .writer(new PurchaseOrderItemWriter("outputFile.txt", jdbcTemplate, transactionManager(), new StepExecution()))
                .build();
    }
}
```

**`JobStartListener.java`**

```java
package com.example.batch;

import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.JobExecutionListener;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.DefaultTransactionDefinition;

@Component
public class JobStartListener implements JobExecutionListener {

    private final JdbcTemplate jdbcTemplate;
    private final PlatformTransactionManager transactionManager;

    public JobStartListener(JdbcTemplate jdbcTemplate, PlatformTransactionManager transactionManager) {
        this.jdbcTemplate = jdbcTemplate;
        this.transactionManager = transactionManager;
    }

    @Override
    public void beforeJob(JobExecution jobExecution) {
        DefaultTransactionDefinition def = new DefaultTransactionDefinition();
        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
        TransactionStatus status = transactionManager.getTransaction(def);

        try {
            // Insert a new summary entry and return the generated summary_id
            Long summaryId = jdbcTemplate.queryForObject(
                "INSERT INTO DailyOrderSummary (total_orders, total_amount) VALUES (0, 0) " +
                "RETURNING summary_id", 
                Long.class
            );

            // Store summary_id in the job execution context
            jobExecution.getExecutionContext().put("summaryId", summaryId);

            transactionManager.commit(status);
        } catch (Exception e) {
            transactionManager.rollback(status);
            throw e;
        }
    }

    @Override
    public void afterJob(JobExecution jobExecution) {
        // No action required after job execution
    }
}
```

**`PurchaseOrderProcessor.java`**

```java
package com.example.batch;

import lombok.RequiredArgsConstructor;
import org.springframework.batch.item.ItemProcessor;
import org.springframework.batch.core.StepExecution;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.DefaultTransactionDefinition;
import org.springframework.jdbc.core.JdbcTemplate;

@RequiredArgsConstructor
public class PurchaseOrderProcessor implements ItemProcessor<PurchaseOrder, PurchaseOrder> {
    private final JdbcTemplate jdbcTemplate;
    private final PlatformTransactionManager transactionManager;
    private final StepExecution stepExecution;

    @Override
    public PurchaseOrder process(PurchaseOrder purchaseOrder) throws Exception {
        Long summaryId = (Long) stepExecution.getJobExecution().getExecutionContext().get("summaryId");

        // Retrieve and update totals in the step execution context
        Integer totalOrders = stepExecution.getExecutionContext().getInt("totalOrders", 0);
        Double totalAmount = stepExecution.getExecutionContext().getDouble("totalAmount", 0.0);

        totalOrders++;
        totalAmount += purchaseOrder.getTotalAmount();

        stepExecution.getExecutionContext().put("totalOrders", totalOrders);
        stepExecution.getExecutionContext().put("totalAmount", totalAmount);

        // Insert into the mapping table with the correct summaryId
        DefaultTransactionDefinition def = new DefaultTransactionDefinition();
        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
        TransactionStatus status = transactionManager.getTransaction(def);

        try {
            jdbcTemplate.update(
                "INSERT INTO DailyOrderSummary_PurchaseOrder (summary_id, purchase_order_id) VALUES (?, ?)",
                summaryId, purchaseOrder.getId()
            );
            transactionManager.commit(status);
        } catch (Exception e) {
            transactionManager.rollback(status);
            throw e;
        }

        return purchaseOrder;
    }
}
```

**`PurchaseOrderItemWriter.java`**

```java
package com.example.batch;

import lombok.RequiredArgsConstructor;
import org.springframework.batch.item.ItemWriter;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.DefaultTransactionDefinition;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.util.List;

@RequiredArgsConstructor
public class PurchaseOrderItemWriter implements ItemWriter<PurchaseOrder> {
    private final String outputPath;
    private final JdbcTemplate jdbcTemplate;
    private final PlatformTransactionManager transactionManager;
    private final StepExecution stepExecution;

    @Override
    public void write(List<? extends PurchaseOrder> items) throws IOException {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(outputPath, true))) {
            for (PurchaseOrder order : items) {
                writer.write(order.toString()); // Adjust the format as needed
                writer.newLine();
            }

            // Retrieve accumulated totals and summaryId from the step context
            Integer totalOrders = stepExecution.getExecutionContext().getInt("totalOrders", 0);
            Double totalAmount = stepExecution.getExecutionContext().getDouble("totalAmount", 0.0);
            Long summaryId = (Long) stepExecution.getJobExecution().getExecutionContext().get("summaryId");

            // Insert or update summary information
            insertOrUpdateSummary(summaryId, totalOrders, totalAmount);
        }
    }

    private void insertOrUpdateSummary(Long summaryId, int totalOrders, double totalAmount) {
        DefaultTransactionDefinition def = new DefaultTransactionDefinition();
        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
        TransactionStatus status = transactionManager.getTransaction(def);

        try {
            jdbcTemplate.update(
                "INSERT INTO DailyOrderSummary (summary_id, total_orders, total_amount) VALUES (?, ?, ?) " +
                "ON CONFLICT (summary_id) DO UPDATE SET total_orders = excluded.total_orders, total_amount = excluded.total_amount",
               

 summaryId, totalOrders, totalAmount
            );
            transactionManager.commit(status);
        } catch (Exception e) {
            transactionManager.rollback(status);
            throw e;
        }
    }
}
```

**`PurchaseOrder.java`**

```java
package com.example.batch;

import lombok.Data;

@Data
public class PurchaseOrder {
    private Long id;
    private Double totalAmount;
    private String orderDate;

    @Override
    public String toString() {
        return id + "," + totalAmount + "," + orderDate;
    }
}
```

**`Application.java`**

```java
package com.example.batch;

import org.springframework.batch.core.Job;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.JobParameters;
import org.springframework.batch.core.launch.JobLauncher;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class Application implements CommandLineRunner {

    @Autowired
    private JobLauncher jobLauncher;

    @Autowired
    private Job rollupJob;

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

    @Override
    public void run(String... args) throws Exception {
        JobExecution jobExecution = jobLauncher.run(rollupJob, new JobParameters());
        System.out.println("Job Status: " + jobExecution.getStatus());
    }
}
```

### Summary

This project setup includes:

- **SQL Schema**: Defines the tables and sequences needed.
- **Batch Configuration**: Configures the batch job, steps, and transaction management.
- **JobStartListener**: Handles the job start event to create a new summary record and retrieve the `summary_id`.
- **PurchaseOrderProcessor**: Processes purchase orders, updates totals, and maps orders to the summary.
- **PurchaseOrderItemWriter**: Writes orders to a file and updates the summary table.
- **PurchaseOrder**: Represents the purchase order data.
- **Application**: The main entry point for running the batch job.






------------
package com.example.batch;

import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.JobExecutionListener;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.DefaultTransactionDefinition;

@Component
public class JobStartListener implements JobExecutionListener {

    private final JdbcTemplate jdbcTemplate;
    private final PlatformTransactionManager transactionManager;

    public JobStartListener(JdbcTemplate jdbcTemplate, PlatformTransactionManager transactionManager) {
        this.jdbcTemplate = jdbcTemplate;
        this.transactionManager = transactionManager;
    }

    @Override
    public void beforeJob(JobExecution jobExecution) {
        DefaultTransactionDefinition def = new DefaultTransactionDefinition();
        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
        TransactionStatus status = transactionManager.getTransaction(def);

        try {
            // Generate a new summary_id
            Long summaryId = jdbcTemplate.queryForObject("SELECT nextval('summary_id_seq')", Long.class);

            // Insert the summary_id into DailyOrderSummary with default values
            jdbcTemplate.update(
                "INSERT INTO DailyOrderSummary (summary_id, total_orders, total_amount) VALUES (?, 0, 0) " +
                "ON CONFLICT (summary_id) DO NOTHING",
                summaryId
            );

            // Store summary_id in the job execution context
            jobExecution.getExecutionContext().put("summaryId", summaryId);

            transactionManager.commit(status);
        } catch (Exception e) {
            transactionManager.rollback(status);
            throw e;
        }
    }

    @Override
    public void afterJob(JobExecution jobExecution) {
        // No action required after job execution
    }
}

——————————

You can now build and run this project using Maven or Gradle. Make sure to replace placeholders in `application.properties` with your actual database credentials.



---
package com.example.batch;

import lombok.RequiredArgsConstructor;
import org.springframework.batch.item.ItemWriter;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.DefaultTransactionDefinition;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.util.List;

@RequiredArgsConstructor
public class PurchaseOrderItemWriter implements ItemWriter<PurchaseOrder> {
    private final String outputPath;
    private final JdbcTemplate jdbcTemplate;
    private final PlatformTransactionManager transactionManager;
    private final StepExecution stepExecution;

    @Override
    public void write(List<? extends PurchaseOrder> items) throws IOException {
        DefaultTransactionDefinition def = new DefaultTransactionDefinition();
        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
        TransactionStatus status = transactionManager.getTransaction(def);

        try (BufferedWriter writer = new BufferedWriter(new FileWriter(outputPath, true))) {
            for (PurchaseOrder order : items) {
                writer.write(order.toString()); // Adjust the format as needed
                writer.newLine();
            }

            // Perform bulk insert into the mapping table
            Long summaryId = (Long) stepExecution.getJobExecution().getExecutionContext().get("summaryId");
            String sql = "INSERT INTO DailyOrderSummary_PurchaseOrder (summary_id, purchase_order_id) VALUES (?, ?)";

            jdbcTemplate.batchUpdate(sql, items, items.size(), (ps, purchaseOrder) -> {
                ps.setLong(1, summaryId);
                ps.setLong(2, purchaseOrder.getId());
            });

            // Retrieve accumulated totals and update the summary table
            Integer totalOrders = stepExecution.getExecutionContext().getInt("totalOrders", 0);
            Double totalAmount = stepExecution.getExecutionContext().getDouble("totalAmount", 0.0);

            insertOrUpdateSummary(summaryId, totalOrders, totalAmount);

            transactionManager.commit(status);
        } catch (Exception e) {
            transactionManager.rollback(status);
            throw e;
        }
    }

    private void insertOrUpdateSummary(Long summaryId, int totalOrders, double totalAmount) {
        jdbcTemplate.update(
            "INSERT INTO DailyOrderSummary (summary_id, total_orders, total_amount) VALUES (?, ?, ?) " +
            "ON CONFLICT (summary_id) DO UPDATE SET total_orders = excluded.total_orders, total_amount = excluded.total_amount",
            summaryId, totalOrders, totalAmount
        );
    }
}




------------
Let's revert to using YAML for externalizing SQL queries. Here's how you can adjust the project to load SQL queries from a YAML file.

### 1. **Create a YAML Configuration File**

Create a YAML configuration file, e.g., `sql-queries.yml`, in the `src/main/resources` directory.

**`sql-queries.yml`**:

```yaml
purchaseOrder:
  insertMapping: "INSERT INTO DailyOrderSummary_PurchaseOrder (summary_id, purchase_order_id) VALUES (?, ?)"
  insertOrUpdateSummary: |
    INSERT INTO DailyOrderSummary (summary_id, total_orders, total_amount) VALUES (?, ?, ?)
    ON CONFLICT (summary_id) DO UPDATE SET total_orders = excluded.total_orders, total_amount = excluded.total_amount
```

### 2. **Load Queries from the YAML File**

You can use the `@ConfigurationProperties` annotation to load the properties from the YAML file.

**`SqlQueriesConfig.java`**:

```java
package com.example.batch;

import lombok.Getter;
import lombok.Setter;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

@Configuration
@ConfigurationProperties(prefix = "purchaseOrder")
@Getter
@Setter
public class SqlQueriesConfig {
    private String insertMapping;
    private String insertOrUpdateSummary;
}
```

### 3. **Configure `application.yml` to Import `sql-queries.yml`**

Ensure that Spring Boot is aware of your `sql-queries.yml` file by importing it in your `application.yml`.

**`application.yml`**:

```yaml
spring:
  config:
    import: "classpath:sql-queries.yml"
```

### 4. **Inject the Queries into `PurchaseOrderItemWriter`**

Now, you can inject the `SqlQueriesConfig` bean into your `PurchaseOrderItemWriter` and use the loaded queries.

**`PurchaseOrderItemWriter.java`**:

```java
package com.example.batch;

import lombok.RequiredArgsConstructor;
import org.springframework.batch.item.ItemWriter;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.DefaultTransactionDefinition;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.util.List;

@RequiredArgsConstructor
public class PurchaseOrderItemWriter implements ItemWriter<PurchaseOrder> {
    private final String outputPath;
    private final JdbcTemplate jdbcTemplate;
    private final PlatformTransactionManager transactionManager;
    private final StepExecution stepExecution;
    private final SqlQueriesConfig sqlQueriesConfig;

    @Override
    public void write(List<? extends PurchaseOrder> items) throws IOException {
        DefaultTransactionDefinition def = new DefaultTransactionDefinition();
        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
        TransactionStatus status = transactionManager.getTransaction(def);

        try (BufferedWriter writer = new BufferedWriter(new FileWriter(outputPath, true))) {
            for (PurchaseOrder order : items) {
                writer.write(order.toString()); // Adjust the format as needed
                writer.newLine();
            }

            // Perform bulk insert into the mapping table using externalized query
            Long summaryId = (Long) stepExecution.getJobExecution().getExecutionContext().get("summaryId");
            String insertMappingQuery = sqlQueriesConfig.getInsertMapping();

            jdbcTemplate.batchUpdate(insertMappingQuery, items, items.size(), (ps, purchaseOrder) -> {
                ps.setLong(1, summaryId);
                ps.setLong(2, purchaseOrder.getId());
            });

            // Retrieve accumulated totals and update the summary table using externalized query
            Integer totalOrders = stepExecution.getExecutionContext().getInt("totalOrders", 0);
            Double totalAmount = stepExecution.getExecutionContext().getDouble("totalAmount", 0.0);
            String insertOrUpdateSummaryQuery = sqlQueriesConfig.getInsertOrUpdateSummary();

            insertOrUpdateSummary(summaryId, totalOrders, totalAmount, insertOrUpdateSummaryQuery);

            transactionManager.commit(status);
        } catch (Exception e) {
            transactionManager.rollback(status);
            throw e;
        }
    }

    private void insertOrUpdateSummary(Long summaryId, int totalOrders, double totalAmount, String query) {
        jdbcTemplate.update(query, summaryId, totalOrders, totalAmount);
    }
}
```

### Summary

- **Externalized Queries**: SQL queries are now stored in `sql-queries.yml`.
- **Configuration Class**: The `SqlQueriesConfig` class is used to load and provide these queries to the writer.
- **Usage**: The `PurchaseOrderItemWriter` class reads the queries from the configuration and uses them in the batch processing logic.

This setup allows you to manage your SQL queries easily from a YAML file, making it easier to update and maintain without altering the codebase.

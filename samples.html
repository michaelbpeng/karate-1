


the complete Spring Boot project structured to handle batch processing with different job types (`Order`, `TVOrder`, `ComputerOrder`), using `JdbcCursorItemReader` with lambda functions for row mapping, and including specific `ItemWriter` implementations for each order type.

### Project Structure

```
batch-processing/
│
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   ├── com/
│   │   │   │   └── example/
│   │   │   │       └── batch/
│   │   │   │           ├── BatchApplication.java
│   │   │   │           ├── config/
│   │   │   │           │   ├── BatchConfig.java
│   │   │   │           │   ├── ZipFileTasklet.java
│   │   │   │           │   └── JobCompletionListener.java
│   │   │   │           ├── entity/
│   │   │   │           │   ├── Order.java
│   │   │   │           │   ├── TVOrder.java
│   │   │   │           │   └── ComputerOrder.java
│   │   │   │           ├── processor/
│   │   │   │           │   └── OrderProcessor.java
│   │   │   │           ├── reader/
│   │   │   │           │   ├── OrderReader.java
│   │   │   │           │   ├── TVOrderReader.java
│   │   │   │           │   └── ComputerOrderReader.java
│   │   │   │           └── writer/
│   │   │   │               ├── OrderItemWriter.java
│   │   │   │               ├── TVOrderItemWriter.java
│   │   │   │               └── ComputerOrderItemWriter.java
│   │   └── resources/
│   │       └── application.properties
└── pom.xml
```

### 1. **`BatchApplication.java`**

```java
package com.example.batch;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class BatchApplication {
    public static void main(String[] args) {
        SpringApplication.run(BatchApplication.class, args);
    }
}
```

### 2. **`BatchConfig.java`**

```java
package com.example.batch.config;

import com.example.batch.entity.ComputerOrder;
import com.example.batch.entity.Order;
import com.example.batch.entity.TVOrder;
import com.example.batch.processor.OrderProcessor;
import com.example.batch.writer.ComputerOrderItemWriter;
import com.example.batch.writer.OrderItemWriter;
import com.example.batch.writer.TVOrderItemWriter;
import com.example.batch.reader.ComputerOrderReader;
import com.example.batch.reader.OrderReader;
import com.example.batch.reader.TVOrderReader;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.Step;
import org.springframework.batch.core.configuration.annotation.EnableBatchProcessing;
import org.springframework.batch.core.configuration.annotation.JobBuilderFactory;
import org.springframework.batch.core.configuration.annotation.StepBuilderFactory;
import org.springframework.batch.core.listener.JobExecutionListenerSupport;
import org.springframework.batch.core.step.tasklet.Tasklet;
import org.springframework.batch.core.step.tasklet.TaskletStep;
import org.springframework.batch.item.ItemProcessor;
import org.springframework.batch.item.ItemReader;
import org.springframework.batch.item.ItemWriter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.io.FileSystemResource;

import javax.sql.DataSource;

@Configuration
@EnableBatchProcessing
public class BatchConfig {

    @Autowired
    private JobBuilderFactory jobBuilderFactory;

    @Autowired
    private StepBuilderFactory stepBuilderFactory;

    @Autowired
    private DataSource dataSource;

    @Autowired
    private OrderItemWriter orderItemWriter;

    @Autowired
    private TVOrderItemWriter tvOrderItemWriter;

    @Autowired
    private ComputerOrderItemWriter computerOrderItemWriter;

    @Autowired
    private JobCompletionListener jobCompletionListener;

    @Autowired
    private ZipFileTasklet zipFileTasklet;

    @Bean
    public Job orderJob() {
        return jobBuilderFactory.get("orderJob")
                .listener(jobCompletionListener)
                .start(processOrderStep())
                .next(zipStep())
                .build();
    }

    @Bean
    public Job tvOrderJob() {
        return jobBuilderFactory.get("tvOrderJob")
                .listener(jobCompletionListener)
                .start(processTVOrderStep())
                .next(zipStep())
                .build();
    }

    @Bean
    public Job computerOrderJob() {
        return jobBuilderFactory.get("computerOrderJob")
                .listener(jobCompletionListener)
                .start(processComputerOrderStep())
                .next(zipStep())
                .build();
    }

    @Bean
    public Step processOrderStep() {
        return stepBuilderFactory.get("processOrderStep")
                .<Order, Order>chunk(10)
                .reader(orderReader())
                .processor(orderProcessor())
                .writer(orderItemWriter)
                .build();
    }

    @Bean
    public Step processTVOrderStep() {
        return stepBuilderFactory.get("processTVOrderStep")
                .<TVOrder, TVOrder>chunk(10)
                .reader(tvOrderReader())
                .processor(orderProcessor())
                .writer(tvOrderItemWriter)
                .build();
    }

    @Bean
    public Step processComputerOrderStep() {
        return stepBuilderFactory.get("processComputerOrderStep")
                .<ComputerOrder, ComputerOrder>chunk(10)
                .reader(computerOrderReader())
                .processor(orderProcessor())
                .writer(computerOrderItemWriter)
                .build();
    }

    @Bean
    public Step zipStep() {
        return stepBuilderFactory.get("zipStep")
                .tasklet(zipFileTasklet)
                .build();
    }

    @Bean
    public ItemReader<Order> orderReader(@Value("#{jobParameters['orderDate']}") String orderDate) {
        return new OrderReader(dataSource, orderDate);
    }

    @Bean
    public ItemReader<TVOrder> tvOrderReader(@Value("#{jobParameters['orderDate']}") String orderDate) {
        return new TVOrderReader(dataSource, orderDate);
    }

    @Bean
    public ItemReader<ComputerOrder> computerOrderReader(@Value("#{jobParameters['orderDate']}") String orderDate) {
        return new ComputerOrderReader(dataSource, orderDate);
    }

    @Bean
    public ItemProcessor<Order, Order> orderProcessor() {
        return new OrderProcessor();
    }
}
```

### 3. **`Order.java`**

```java
package com.example.batch.entity;

import java.time.LocalDate;

public class Order {
    private int orderId;
    private String customerName;
    private LocalDate orderDate;
    private double totalAmount;

    // Getters and Setters
}
```

### 4. **`TVOrder.java`**

```java
package com.example.batch.entity;

public class TVOrder extends Order {
    // Additional fields or methods specific to TVOrder if needed
}
```

### 5. **`ComputerOrder.java`**

```java
package com.example.batch.entity;

public class ComputerOrder extends Order {
    // Additional fields or methods specific to ComputerOrder if needed
}
```

### 6. **`OrderProcessor.java`**

```java
package com.example.batch.processor;

import com.example.batch.entity.Order;
import org.springframework.batch.item.ItemProcessor;
import org.springframework.stereotype.Component;

@Component
public class OrderProcessor implements ItemProcessor<Order, Order> {

    @Override
    public Order process(Order item) {
        // Implement your processing logic here
        return item;
    }
}
```

### 7. **`OrderReader.java`**

```java
package com.example.batch.reader;

import com.example.batch.entity.Order;
import org.springframework.batch.item.database.JdbcCursorItemReader;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import javax.sql.DataSource;

@Component
public class OrderReader extends JdbcCursorItemReader<Order> {

    public OrderReader(DataSource dataSource, @Value("#{jobParameters['orderDate']}") String orderDate) {
        setDataSource(dataSource);
        setSql("SELECT order_id, customer_name, order_date, total_amount FROM orders WHERE order_date = ?");
        setPreparedStatementSetter(ps -> ps.setString(1, orderDate));
        setRowMapper((rs, rowNum) -> {
            Order order = new Order();
            order.setOrderId(rs.getInt("order_id"));
            order.setCustomerName(rs.getString("customer_name"));
            order.setOrderDate(rs.getDate("order_date").toLocalDate());
            order.setTotalAmount(rs.getDouble("total_amount"));
            return order;
        });
    }
}
```

### 8. **`TVOrderReader.java`**

```java
package com.example.batch.reader;

import com.example.batch.entity.TVOrder;
import org.springframework.batch.item.database.JdbcCursorItemReader;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import javax.sql.DataSource;

@Component
public class TVOrderReader extends JdbcCursorItemReader<TVOrder> {

    public TVOrderReader(DataSource dataSource, @Value("#{jobParameters['orderDate']}") String orderDate) {
        setDataSource(dataSource);
        setSql("SELECT order_id, customer_name, order_date, total_amount FROM tv_orders WHERE order_date = ?");
        setPreparedStatementSetter(ps -> ps.setString(1, orderDate));
        setRowMapper((

rs, rowNum) -> {
            TVOrder tvOrder = new TVOrder();
            tvOrder.setOrderId(rs.getInt("order_id"));
            tvOrder.setCustomerName(rs.getString("customer_name"));
            tvOrder.setOrderDate(rs.getDate("order_date").toLocalDate());
            tvOrder.setTotalAmount(rs.getDouble("total_amount"));
            return tvOrder;
        });
    }
}
```

### 9. **`ComputerOrderReader.java`**

```java
package com.example.batch.reader;

import com.example.batch.entity.ComputerOrder;
import org.springframework.batch.item.database.JdbcCursorItemReader;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import javax.sql.DataSource;

@Component
public class ComputerOrderReader extends JdbcCursorItemReader<ComputerOrder> {

    public ComputerOrderReader(DataSource dataSource, @Value("#{jobParameters['orderDate']}") String orderDate) {
        setDataSource(dataSource);
        setSql("SELECT order_id, customer_name, order_date, total_amount FROM computer_orders WHERE order_date = ?");
        setPreparedStatementSetter(ps -> ps.setString(1, orderDate));
        setRowMapper((rs, rowNum) -> {
            ComputerOrder computerOrder = new ComputerOrder();
            computerOrder.setOrderId(rs.getInt("order_id"));
            computerOrder.setCustomerName(rs.getString("customer_name"));
            computerOrder.setOrderDate(rs.getDate("order_date").toLocalDate());
            computerOrder.setTotalAmount(rs.getDouble("total_amount"));
            return computerOrder;
        });
    }
}
```

### 10. **`OrderItemWriter.java`**

```java
package com.example.batch.writer;

import com.example.batch.entity.Order;
import org.springframework.batch.item.file.FlatFileItemWriter;
import org.springframework.batch.item.file.transform.LineAggregator;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.FileSystemResource;
import org.springframework.stereotype.Component;

import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.List;

@Component
public class OrderItemWriter extends FlatFileItemWriter<Order> {

    private double totalAmount = 0.0;
    private int totalCount = 0;
    private final String outputFileName;

    public OrderItemWriter(@Value("#{jobParameters['orderDate']}") String orderDate) {
        this.outputFileName = "order-" + LocalDate.now().format(DateTimeFormatter.ISO_DATE) + ".csv";
        setResource(new FileSystemResource(outputFileName));
        setLineAggregator((LineAggregator<Order>) order -> String.format("%d,%s,%s,%.2f",
            order.getOrderId(),
            order.getCustomerName(),
            order.getOrderDate(),
            order.getTotalAmount()));
        setHeaderCallback(writer -> writer.write("Order ID,Customer Name,Order Date,Total Amount"));
        setFooterCallback(writer -> {
            writer.write("Total Records: " + totalCount + "\n");
            writer.write("Total Amount: " + totalAmount + "\n");
        });
    }

    @Override
    public void write(List<? extends Order> items) {
        for (Order item : items) {
            totalAmount += item.getTotalAmount();
            totalCount++;
        }
        super.write(items);
    }
}
```

### 11. **`TVOrderItemWriter.java`**

```java
package com.example.batch.writer;

import com.example.batch.entity.TVOrder;
import org.springframework.batch.item.file.FlatFileItemWriter;
import org.springframework.batch.item.file.transform.LineAggregator;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.FileSystemResource;
import org.springframework.stereotype.Component;

import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.List;

@Component
public class TVOrderItemWriter extends FlatFileItemWriter<TVOrder> {

    private double totalAmount = 0.0;
    private int totalCount = 0;
    private final String outputFileName;

    public TVOrderItemWriter(@Value("#{jobParameters['orderDate']}") String orderDate) {
        this.outputFileName = "tvorder-" + LocalDate.now().format(DateTimeFormatter.ISO_DATE) + ".csv";
        setResource(new FileSystemResource(outputFileName));
        setLineAggregator((LineAggregator<TVOrder>) tvOrder -> String.format("%d,%s,%s,%.2f",
            tvOrder.getOrderId(),
            tvOrder.getCustomerName(),
            tvOrder.getOrderDate(),
            tvOrder.getTotalAmount()));
        setHeaderCallback(writer -> writer.write("Order ID,Customer Name,Order Date,Total Amount"));
        setFooterCallback(writer -> {
            writer.write("Total Records: " + totalCount + "\n");
            writer.write("Total Amount: " + totalAmount + "\n");
        });
    }

    @Override
    public void write(List<? extends TVOrder> items) {
        for (TVOrder item : items) {
            totalAmount += item.getTotalAmount();
            totalCount++;
        }
        super.write(items);
    }
}
```

### 12. **`ComputerOrderItemWriter.java`**

```java
package com.example.batch.writer;

import com.example.batch.entity.ComputerOrder;
import org.springframework.batch.item.file.FlatFileItemWriter;
import org.springframework.batch.item.file.transform.LineAggregator;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.FileSystemResource;
import org.springframework.stereotype.Component;

import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.List;

@Component
public class ComputerOrderItemWriter extends FlatFileItemWriter<ComputerOrder> {

    private double totalAmount = 0.0;
    private int totalCount = 0;
    private final String outputFileName;

    public ComputerOrderItemWriter(@Value("#{jobParameters['orderDate']}") String orderDate) {
        this.outputFileName = "computerorder-" + LocalDate.now().format(DateTimeFormatter.ISO_DATE) + ".csv";
        setResource(new FileSystemResource(outputFileName));
        setLineAggregator((LineAggregator<ComputerOrder>) computerOrder -> String.format("%d,%s,%s,%.2f",
            computerOrder.getOrderId(),
            computerOrder.getCustomerName(),
            computerOrder.getOrderDate(),
            computerOrder.getTotalAmount()));
        setHeaderCallback(writer -> writer.write("Order ID,Customer Name,Order Date,Total Amount"));
        setFooterCallback(writer -> {
            writer.write("Total Records: " + totalCount + "\n");
            writer.write("Total Amount: " + totalAmount + "\n");
        });
    }

    @Override
    public void write(List<? extends ComputerOrder> items) {
        for (ComputerOrder item : items) {
            totalAmount += item.getTotalAmount();
            totalCount++;
        }
        super.write(items);
    }
}
```

### 13. **`ZipFileTasklet.java`**

```java
package com.example.batch.config;

import org.springframework.batch.core.StepContribution;
import org.springframework.batch.core.job.flow.support.state.TaskletStep;
import org.springframework.batch.core.step.tasklet.Tasklet;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.FileSystemResource;
import org.springframework.stereotype.Component;
import org.springframework.batch.repeat.RepeatStatus;

import java.io.*;
import java.nio.file.*;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

@Component
public class ZipFileTasklet implements Tasklet {

    @Value("#{jobExecutionContext['outputFileName']}")
    private String outputFileName;

    @Value("#{jobExecutionContext['totalAmount']}")
    private Double totalAmount;

    @Value("#{jobExecutionContext['totalCount']}")
    private Integer totalCount;

    @Override
    public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {
        Path filePath = Paths.get(outputFileName);
        Path zipPath = Paths.get(filePath.toString().replace(".csv", ".zip"));
        Path tagFilePath = Paths.get(filePath.toString().replace(".csv", "-tag.txt"));

        try (ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zipPath.toFile()));
             BufferedWriter tagFileWriter = Files.newBufferedWriter(tagFilePath, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {

            // Add the CSV file to the ZIP file
            try (FileInputStream fis = new FileInputStream(filePath.toFile())) {
                ZipEntry zipEntry = new ZipEntry(filePath.getFileName().toString());
                zos.putNextEntry(zipEntry);
                byte[] buffer = new byte[1024];
                int length;
                while ((length = fis.read(buffer)) > 0) {
                    zos.write(buffer, 0, length);
                }
                zos.closeEntry();
            }

            // Create the tag file
            tagFileWriter.write("Total Records: " + totalCount + "\n");
            tagFileWriter.write("Total Amount: " + totalAmount + "\n");
        }

        return RepeatStatus.FINISHED;
    }
}
```

### 14. **`JobCompletionListener.java`**

```java
package com.example.batch.listener;

import com.example.batch.writer.OrderItemWriter;
import com.example.batch.writer.TVOrderItemWriter;
import com.example.batch.writer.ComputerOrderItemWriter;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.JobExecutionListener;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class JobCompletionListener implements JobExecutionListener {

    @Autowired
    private OrderItemWriter orderItemWriter;

    @Autowired
    private TVOrderItemWriter tvOrderItemWriter;

    @Autowired
    private ComputerOrderItemWriter computerOrderItemWriter;

    @Override
    public void beforeJob(JobExecution jobExecution) {
        // No action needed before job starts
    }

    @Override
    public void afterJob(JobExecution jobExecution) {
        String jobName = jobExecution.getJobInstance().getJobName();
        if (jobName.equals("orderJob")) {
            jobExecution.getExecutionContext().put("outputFileName", orderItemWriter.getOutputFileName());
            jobExecution.getExecutionContext().put("totalAmount", orderItemWriter.getTotalAmount());
            jobExecution.getExecutionContext().put("totalCount", orderItemWriter.getTotalCount());
        } else if (jobName.equals("tvOrderJob")) {
            jobExecution.getExecutionContext().put("outputFileName", tvOrderItemWriter.getOutputFileName());
            jobExecution.getExecutionContext().put("totalAmount", tvOrderItemWriter.getTotalAmount());
            jobExecution.getExecutionContext().put("totalCount", tvOrderItemWriter.getTotalCount());
        } else if (jobName.equals("computerOrderJob")) {
            jobExecution.getExecutionContext().put("outputFileName", computerOrderItemWriter.getOutputFileName());
            jobExecution.getExecutionContext().put("totalAmount", computerOrderItemWriter.getTotalAmount());
            jobExecution.getExecutionContext().put("totalCount", computerOrderItemWriter.getTotalCount());
        }
        System.out.println("Job execution completed: " + jobName);
    }
}

```

### 15. **`application.properties`**

```properties
spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driver-class-name=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=password
spring.batch.job.enabled=false


```

### **Explanation**

- **Data Entities**: `Order`, `TVOrder`, and `ComputerOrder` represent the different types of orders.
- **Readers**: `OrderReader`, `TVOrderReader`, and `ComputerOrderReader` use `JdbcCursorItemReader` to read data from the database. Row mapping is done using lambda functions.
- **Processors**: `OrderProcessor` handles processing logic for all order types.
- **Writers**: `OrderItemWriter`, `TVOrderItemWriter`, and `ComputerOrderItemWriter` write data to CSV files, with specific implementations for each order type.
- **Jobs**: Configured for `Order`, `TVOrder`, and `ComputerOrder`, using the same processing and writing steps but with different readers and writers.
- **Tasklets**: `ZipFileTasklet` creates a ZIP file of the output CSV and a tag file.
- **Listeners**: `JobCompletionListener` logs the job completion.

This configuration ensures that each job type (Order, TVOrder, ComputerOrder) has its own job configuration but shares common processing logic, making the codebase clean and reusable.




ere is the complete project structure, including all Java classes necessary to handle `TVOrder` and `ComputerOrder` with separate jobs but leveraging code reuse and abstraction.

### **Project Structure**

```
src
└── main
    └── java
        └── com
            └── example
                └── batch
                    ├── BatchApplication.java
                    ├── config
                    │   ├── AbstractOrderJobConfig.java
                    │   ├── TVOrderJobConfig.java
                    │   ├── ComputerOrderJobConfig.java
                    │   └── ZipFileTasklet.java
                    ├── entity
                    │   ├── Order.java
                    │   ├── TVOrder.java
                    │   └── ComputerOrder.java
                    ├── listener
                    │   └── JobCompletionListener.java
                    ├── mapper
                    │   ├── OrderRowMapper.java
                    │   ├── TVOrderRowMapper.java
                    │   └── ComputerOrderRowMapper.java
                    ├── processor
                    │   └── OrderProcessor.java
                    ├── reader
                    │   ├── OrderReader.java
                    │   ├── TVOrderReader.java
                    │   └── ComputerOrderReader.java
                    └── writer
                        ├── OrderItemWriter.java
                        ├── TVOrderItemWriter.java
                        └── ComputerOrderItemWriter.java
```

### **1. `BatchApplication.java`**

```java
package com.example.batch;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class BatchApplication {
    public static void main(String[] args) {
        SpringApplication.run(BatchApplication.class, args);
    }
}
```

### **2. `config/AbstractOrderJobConfig.java**

```java
package com.example.batch.config;

import com.example.batch.processor.OrderProcessor;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.Step;
import org.springframework.batch.core.configuration.annotation.JobBuilderFactory;
import org.springframework.batch.core.configuration.annotation.StepBuilderFactory;
import org.springframework.batch.core.step.tasklet.Tasklet;
import org.springframework.batch.item.ItemProcessor;
import org.springframework.batch.item.ItemReader;
import org.springframework.batch.item.ItemWriter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public abstract class AbstractOrderJobConfig<T> {

    @Autowired
    protected JobBuilderFactory jobBuilderFactory;

    @Autowired
    protected StepBuilderFactory stepBuilderFactory;

    @Bean
    public abstract Job orderJob(Step processStep, Step zipStep);

    @Bean
    public abstract Step processStep();

    @Bean
    public abstract Step zipStep();

    protected Step processStep(ItemReader<T> reader, ItemProcessor<T, T> processor, ItemWriter<T> writer) {
        return stepBuilderFactory.get(getProcessStepName())
                .<T, T>chunk(10)
                .reader(reader)
                .processor(processor)
                .writer(writer)
                .build();
    }

    protected Step zipStep() {
        return stepBuilderFactory.get(getZipStepName())
                .tasklet(new ZipFileTasklet())
                .build();
    }

    protected abstract String getJobName();
    protected abstract String getProcessStepName();
    protected abstract String getZipStepName();
    protected abstract ItemReader<T> getOrderReader();
    protected abstract ItemWriter<T> getItemWriter();
}
```

### **3. `config/TVOrderJobConfig.java`**

```java
package com.example.batch.config;

import com.example.batch.entity.TVOrder;
import com.example.batch.writer.TVOrderItemWriter;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.Step;
import org.springframework.batch.core.configuration.annotation.EnableBatchProcessing;
import org.springframework.batch.core.configuration.annotation.JobBuilderFactory;
import org.springframework.batch.core.configuration.annotation.StepBuilderFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@EnableBatchProcessing
public class TVOrderJobConfig extends AbstractOrderJobConfig<TVOrder> {

    @Autowired
    private TVOrderReader tvOrderReader;

    @Autowired
    private TVOrderItemWriter tvOrderItemWriter;

    @Bean
    @Override
    public Job orderJob(Step processStep, Step zipStep) {
        return jobBuilderFactory.get(getJobName())
                .start(processStep)
                .next(zipStep)
                .build();
    }

    @Bean
    @Override
    public Step processStep() {
        return super.processStep(tvOrderReader, new OrderProcessor(), tvOrderItemWriter);
    }

    @Bean
    @Override
    public Step zipStep() {
        return super.zipStep();
    }

    @Override
    protected String getJobName() {
        return "tvOrderJob";
    }

    @Override
    protected String getProcessStepName() {
        return "tvOrderProcessStep";
    }

    @Override
    protected String getZipStepName() {
        return "tvOrderZipStep";
    }

    @Override
    protected TVOrderReader getOrderReader() {
        return tvOrderReader;
    }

    @Override
    protected TVOrderItemWriter getItemWriter() {
        return tvOrderItemWriter;
    }
}
```

### **4. `config/ComputerOrderJobConfig.java`**

```java
package com.example.batch.config;

import com.example.batch.entity.ComputerOrder;
import com.example.batch.writer.ComputerOrderItemWriter;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.Step;
import org.springframework.batch.core.configuration.annotation.EnableBatchProcessing;
import org.springframework.batch.core.configuration.annotation.JobBuilderFactory;
import org.springframework.batch.core.configuration.annotation.StepBuilderFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@EnableBatchProcessing
public class ComputerOrderJobConfig extends AbstractOrderJobConfig<ComputerOrder> {

    @Autowired
    private ComputerOrderReader computerOrderReader;

    @Autowired
    private ComputerOrderItemWriter computerOrderItemWriter;

    @Bean
    @Override
    public Job orderJob(Step processStep, Step zipStep) {
        return jobBuilderFactory.get(getJobName())
                .start(processStep)
                .next(zipStep)
                .build();
    }

    @Bean
    @Override
    public Step processStep() {
        return super.processStep(computerOrderReader, new OrderProcessor(), computerOrderItemWriter);
    }

    @Bean
    @Override
    public Step zipStep() {
        return super.zipStep();
    }

    @Override
    protected String getJobName() {
        return "computerOrderJob";
    }

    @Override
    protected String getProcessStepName() {
        return "computerOrderProcessStep";
    }

    @Override
    protected String getZipStepName() {
        return "computerOrderZipStep";
    }

    @Override
    protected ComputerOrderReader getOrderReader() {
        return computerOrderReader;
    }

    @Override
    protected ComputerOrderItemWriter getItemWriter() {
        return computerOrderItemWriter;
    }
}
```

### **5. `config/ZipFileTasklet.java`**

```java
package com.example.batch.config;

import org.springframework.batch.core.StepContribution;
import org.springframework.batch.core.job.flow.support.state.TaskletStep;
import org.springframework.batch.core.step.tasklet.Tasklet;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.FileSystemResource;
import org.springframework.stereotype.Component;
import org.springframework.batch.repeat.RepeatStatus;

import java.io.*;
import java.nio.file.*;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

@Component
public class ZipFileTasklet implements Tasklet {

    @Value("#{jobExecutionContext['outputFileName']}")
    private String outputFileName;

    @Value("#{jobExecutionContext['totalAmount']}")
    private Double totalAmount;

    @Value("#{jobExecutionContext['totalCount']}")
    private Integer totalCount;

    @Override
    public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {
        Path filePath = Paths.get(outputFileName);
        Path zipPath = Paths.get(filePath.toString().replace(".csv", ".zip"));
        Path tagFilePath = Paths.get(filePath.toString().replace(".csv", "-tag.txt"));

        try (ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zipPath.toFile()));
             BufferedWriter tagFileWriter = Files.newBufferedWriter(tagFilePath, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {

            // Add the CSV file to the ZIP file
            try (FileInputStream fis = new FileInputStream(filePath.toFile())) {
                ZipEntry zipEntry = new ZipEntry(filePath.getFileName().toString());
                zos.putNextEntry(zipEntry);
                byte[] buffer = new byte[1024];
                int length;
                while ((length = fis.read(buffer)) > 0) {
                    zos.write(buffer, 0, length);
                }
                zos.closeEntry();
            }

            // Create the tag file
            tagFileWriter.write("Total Records: " + totalCount + "\n");
            tagFileWriter.write("Total Amount: " + totalAmount + "\n");
        }

        return RepeatStatus.FINISHED;
    }
}
```

### **6. `entity/Order.java`**

```java
package com.example.batch.entity;

import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDate;

@Data
@NoArgsConstructor
public class Order {
    private int orderId;
    private String customerName;
    private LocalDate orderDate;
    private

 double amount;
}
```

### **7. `entity/TVOrder.java`**

```java
package com.example.batch.entity;

public class TVOrder extends Order {
    private String tvModel;

    // Getters and setters
}
```

### **8. `entity/ComputerOrder.java`**

```java
package com.example.batch.entity;

public class ComputerOrder extends Order {
    private String computerModel;

    // Getters and setters
}
```

### **9. `mapper/OrderRowMapper.java`**

```java
package com.example.batch.mapper;

import com.example.batch.entity.Order;
import org.springframework.jdbc.core.RowMapper;

import java.sql.ResultSet;
import java.sql.SQLException;

public abstract class OrderRowMapper<T extends Order> implements RowMapper<T> {

    @Override
    public T mapRow(ResultSet rs, int rowNum) throws SQLException {
        T order = createOrder();
        order.setOrderId(rs.getInt("order_id"));
        order.setCustomerName(rs.getString("customer_name"));
        order.setOrderDate(rs.getDate("order_date").toLocalDate());
        order.setAmount(rs.getDouble("amount"));
        mapAdditionalFields(rs, order);
        return order;
    }

    protected abstract T createOrder();
    protected abstract void mapAdditionalFields(ResultSet rs, T order) throws SQLException;
}
```

### **10. `mapper/TVOrderRowMapper.java`**

```java
package com.example.batch.mapper;

import com.example.batch.entity.TVOrder;
import org.springframework.stereotype.Component;

import java.sql.ResultSet;
import java.sql.SQLException;

@Component
public class TVOrderRowMapper extends OrderRowMapper<TVOrder> {

    @Override
    protected TVOrder createOrder() {
        return new TVOrder();
    }

    @Override
    protected void mapAdditionalFields(ResultSet rs, TVOrder order) throws SQLException {
        order.setTvModel(rs.getString("tv_model"));
    }
}
```

### **11. `mapper/ComputerOrderRowMapper.java`**

```java
package com.example.batch.mapper;

import com.example.batch.entity.ComputerOrder;
import org.springframework.stereotype.Component;

import java.sql.ResultSet;
import java.sql.SQLException;

@Component
public class ComputerOrderRowMapper extends OrderRowMapper<ComputerOrder> {

    @Override
    protected ComputerOrder createOrder() {
        return new ComputerOrder();
    }

    @Override
    protected void mapAdditionalFields(ResultSet rs, ComputerOrder order) throws SQLException {
        order.setComputerModel(rs.getString("computer_model"));
    }
}
```

### **12. `processor/OrderProcessor.java`**

```java
package com.example.batch.processor;

import com.example.batch.entity.Order;
import org.springframework.batch.item.ItemProcessor;
import org.springframework.stereotype.Component;

@Component
public class OrderProcessor implements ItemProcessor<Order, Order> {

    @Override
    public Order process(Order order) throws Exception {
        // Add custom processing logic if needed
        return order;
    }
}
```

### **13. `reader/OrderReader.java`**

```java
package com.example.batch.reader;

import com.example.batch.entity.Order;
import com.example.batch.mapper.OrderRowMapper;
import org.springframework.batch.item.database.JdbcCursorItemReader;
import org.springframework.stereotype.Component;

@Component
public abstract class OrderReader<T extends Order> extends JdbcCursorItemReader<T> {

    public OrderReader(String sql, OrderRowMapper<T> rowMapper) {
        super();
        setSql(sql);
        setRowMapper(rowMapper);
        setFetchSize(10);
    }
}
```

### **14. `reader/TVOrderReader.java`**

```java
package com.example.batch.reader;

import com.example.batch.entity.TVOrder;
import com.example.batch.mapper.TVOrderRowMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class TVOrderReader extends OrderReader<TVOrder> {

    @Autowired
    public TVOrderReader(TVOrderRowMapper rowMapper) {
        super("SELECT * FROM tv_orders", rowMapper);
    }
}
```

### **15. `reader/ComputerOrderReader.java`**

```java
package com.example.batch.reader;

import com.example.batch.entity.ComputerOrder;
import com.example.batch.mapper.ComputerOrderRowMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class ComputerOrderReader extends OrderReader<ComputerOrder> {

    @Autowired
    public ComputerOrderReader(ComputerOrderRowMapper rowMapper) {
        super("SELECT * FROM computer_orders", rowMapper);
    }
}
```

### **16. `writer/OrderItemWriter.java`**

```java
package com.example.batch.writer;

import com.example.batch.entity.Order;
import org.springframework.batch.item.ItemWriter;
import org.springframework.stereotype.Component;

import java.util.List;

@Component
public abstract class OrderItemWriter<T extends Order> implements ItemWriter<T> {

    @Override
    public void write(List<? extends T> items) throws Exception {
        // Default implementation can be overridden in specific writers
        for (T item : items) {
            writeItem(item);
        }
    }

    protected abstract void writeItem(T item) throws Exception;
}
```

### **17. `writer/TVOrderItemWriter.java`**

```java
package com.example.batch.writer;

import com.example.batch.entity.TVOrder;
import org.springframework.stereotype.Component;

@Component
public class TVOrderItemWriter extends OrderItemWriter<TVOrder> {

    @Override
    protected void writeItem(TVOrder item) throws Exception {
        // Implementation for writing TVOrder
        System.out.println("Writing TV Order: " + item);
    }
}
```

### **18. `writer/ComputerOrderItemWriter.java`**

```java
package com.example.batch.writer;

import com.example.batch.entity.ComputerOrder;
import org.springframework.stereotype.Component;

@Component
public class ComputerOrderItemWriter extends OrderItemWriter<ComputerOrder> {

    @Override
    protected void writeItem(ComputerOrder item) throws Exception {
        // Implementation for writing ComputerOrder
        System.out.println("Writing Computer Order: " + item);
    }
}
```

### **19. `listener/JobCompletionListener.java`**

```java
package com.example.batch.listener;

import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.JobExecutionListener;
import org.springframework.batch.core.annotation.AfterJob;
import org.springframework.batch.core.annotation.BeforeJob;
import org.springframework.stereotype.Component;

@Component
public class JobCompletionListener implements JobExecutionListener {

    @Override
    @BeforeJob
    public void beforeJob(JobExecution jobExecution) {
        System.out.println("Starting job: " + jobExecution.getJobInstance().getJobName());
    }

    @Override
    @AfterJob
    public void afterJob(JobExecution jobExecution) {
        System.out.println("Job completed with status: " + jobExecution.getStatus());
    }
}
```

### **20. `application.properties`**

```properties
spring.batch.job.enabled=false
```

This configuration should allow you to handle `TVOrder` and `ComputerOrder` types with separate jobs, but share common logic and configuration wherever possible to maximize code reuse and maintainability.


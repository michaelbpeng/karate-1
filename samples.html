


the complete Spring Boot project structured to handle batch processing with different job types (`Order`, `TVOrder`, `ComputerOrder`), using `JdbcCursorItemReader` with lambda functions for row mapping, and including specific `ItemWriter` implementations for each order type.

### Project Structure

```
batch-processing/
│
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   ├── com/
│   │   │   │   └── example/
│   │   │   │       └── batch/
│   │   │   │           ├── BatchApplication.java
│   │   │   │           ├── config/
│   │   │   │           │   ├── BatchConfig.java
│   │   │   │           │   ├── ZipFileTasklet.java
│   │   │   │           │   └── JobCompletionListener.java
│   │   │   │           ├── entity/
│   │   │   │           │   ├── Order.java
│   │   │   │           │   ├── TVOrder.java
│   │   │   │           │   └── ComputerOrder.java
│   │   │   │           ├── processor/
│   │   │   │           │   └── OrderProcessor.java
│   │   │   │           ├── reader/
│   │   │   │           │   ├── OrderReader.java
│   │   │   │           │   ├── TVOrderReader.java
│   │   │   │           │   └── ComputerOrderReader.java
│   │   │   │           └── writer/
│   │   │   │               ├── OrderItemWriter.java
│   │   │   │               ├── TVOrderItemWriter.java
│   │   │   │               └── ComputerOrderItemWriter.java
│   │   └── resources/
│   │       └── application.properties
└── pom.xml
```

### 1. **`BatchApplication.java`**

```java
package com.example.batch;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class BatchApplication {
    public static void main(String[] args) {
        SpringApplication.run(BatchApplication.class, args);
    }
}
```

### 2. **`BatchConfig.java`**

```java
package com.example.batch.config;

import com.example.batch.entity.ComputerOrder;
import com.example.batch.entity.Order;
import com.example.batch.entity.TVOrder;
import com.example.batch.processor.OrderProcessor;
import com.example.batch.writer.ComputerOrderItemWriter;
import com.example.batch.writer.OrderItemWriter;
import com.example.batch.writer.TVOrderItemWriter;
import com.example.batch.reader.ComputerOrderReader;
import com.example.batch.reader.OrderReader;
import com.example.batch.reader.TVOrderReader;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.Step;
import org.springframework.batch.core.configuration.annotation.EnableBatchProcessing;
import org.springframework.batch.core.configuration.annotation.JobBuilderFactory;
import org.springframework.batch.core.configuration.annotation.StepBuilderFactory;
import org.springframework.batch.core.listener.JobExecutionListenerSupport;
import org.springframework.batch.core.step.tasklet.Tasklet;
import org.springframework.batch.core.step.tasklet.TaskletStep;
import org.springframework.batch.item.ItemProcessor;
import org.springframework.batch.item.ItemReader;
import org.springframework.batch.item.ItemWriter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.io.FileSystemResource;

import javax.sql.DataSource;

@Configuration
@EnableBatchProcessing
public class BatchConfig {

    @Autowired
    private JobBuilderFactory jobBuilderFactory;

    @Autowired
    private StepBuilderFactory stepBuilderFactory;

    @Autowired
    private DataSource dataSource;

    @Autowired
    private OrderItemWriter orderItemWriter;

    @Autowired
    private TVOrderItemWriter tvOrderItemWriter;

    @Autowired
    private ComputerOrderItemWriter computerOrderItemWriter;

    @Autowired
    private JobCompletionListener jobCompletionListener;

    @Autowired
    private ZipFileTasklet zipFileTasklet;

    @Bean
    public Job orderJob() {
        return jobBuilderFactory.get("orderJob")
                .listener(jobCompletionListener)
                .start(processOrderStep())
                .next(zipStep())
                .build();
    }

    @Bean
    public Job tvOrderJob() {
        return jobBuilderFactory.get("tvOrderJob")
                .listener(jobCompletionListener)
                .start(processTVOrderStep())
                .next(zipStep())
                .build();
    }

    @Bean
    public Job computerOrderJob() {
        return jobBuilderFactory.get("computerOrderJob")
                .listener(jobCompletionListener)
                .start(processComputerOrderStep())
                .next(zipStep())
                .build();
    }

    @Bean
    public Step processOrderStep() {
        return stepBuilderFactory.get("processOrderStep")
                .<Order, Order>chunk(10)
                .reader(orderReader())
                .processor(orderProcessor())
                .writer(orderItemWriter)
                .build();
    }

    @Bean
    public Step processTVOrderStep() {
        return stepBuilderFactory.get("processTVOrderStep")
                .<TVOrder, TVOrder>chunk(10)
                .reader(tvOrderReader())
                .processor(orderProcessor())
                .writer(tvOrderItemWriter)
                .build();
    }

    @Bean
    public Step processComputerOrderStep() {
        return stepBuilderFactory.get("processComputerOrderStep")
                .<ComputerOrder, ComputerOrder>chunk(10)
                .reader(computerOrderReader())
                .processor(orderProcessor())
                .writer(computerOrderItemWriter)
                .build();
    }

    @Bean
    public Step zipStep() {
        return stepBuilderFactory.get("zipStep")
                .tasklet(zipFileTasklet)
                .build();
    }

    @Bean
    public ItemReader<Order> orderReader(@Value("#{jobParameters['orderDate']}") String orderDate) {
        return new OrderReader(dataSource, orderDate);
    }

    @Bean
    public ItemReader<TVOrder> tvOrderReader(@Value("#{jobParameters['orderDate']}") String orderDate) {
        return new TVOrderReader(dataSource, orderDate);
    }

    @Bean
    public ItemReader<ComputerOrder> computerOrderReader(@Value("#{jobParameters['orderDate']}") String orderDate) {
        return new ComputerOrderReader(dataSource, orderDate);
    }

    @Bean
    public ItemProcessor<Order, Order> orderProcessor() {
        return new OrderProcessor();
    }
}
```

### 3. **`Order.java`**

```java
package com.example.batch.entity;

import java.time.LocalDate;

public class Order {
    private int orderId;
    private String customerName;
    private LocalDate orderDate;
    private double totalAmount;

    // Getters and Setters
}
```

### 4. **`TVOrder.java`**

```java
package com.example.batch.entity;

public class TVOrder extends Order {
    // Additional fields or methods specific to TVOrder if needed
}
```

### 5. **`ComputerOrder.java`**

```java
package com.example.batch.entity;

public class ComputerOrder extends Order {
    // Additional fields or methods specific to ComputerOrder if needed
}
```

### 6. **`OrderProcessor.java`**

```java
package com.example.batch.processor;

import com.example.batch.entity.Order;
import org.springframework.batch.item.ItemProcessor;
import org.springframework.stereotype.Component;

@Component
public class OrderProcessor implements ItemProcessor<Order, Order> {

    @Override
    public Order process(Order item) {
        // Implement your processing logic here
        return item;
    }
}
```

### 7. **`OrderReader.java`**

```java
package com.example.batch.reader;

import com.example.batch.entity.Order;
import org.springframework.batch.item.database.JdbcCursorItemReader;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import javax.sql.DataSource;

@Component
public class OrderReader extends JdbcCursorItemReader<Order> {

    public OrderReader(DataSource dataSource, @Value("#{jobParameters['orderDate']}") String orderDate) {
        setDataSource(dataSource);
        setSql("SELECT order_id, customer_name, order_date, total_amount FROM orders WHERE order_date = ?");
        setPreparedStatementSetter(ps -> ps.setString(1, orderDate));
        setRowMapper((rs, rowNum) -> {
            Order order = new Order();
            order.setOrderId(rs.getInt("order_id"));
            order.setCustomerName(rs.getString("customer_name"));
            order.setOrderDate(rs.getDate("order_date").toLocalDate());
            order.setTotalAmount(rs.getDouble("total_amount"));
            return order;
        });
    }
}
```

### 8. **`TVOrderReader.java`**

```java
package com.example.batch.reader;

import com.example.batch.entity.TVOrder;
import org.springframework.batch.item.database.JdbcCursorItemReader;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import javax.sql.DataSource;

@Component
public class TVOrderReader extends JdbcCursorItemReader<TVOrder> {

    public TVOrderReader(DataSource dataSource, @Value("#{jobParameters['orderDate']}") String orderDate) {
        setDataSource(dataSource);
        setSql("SELECT order_id, customer_name, order_date, total_amount FROM tv_orders WHERE order_date = ?");
        setPreparedStatementSetter(ps -> ps.setString(1, orderDate));
        setRowMapper((

rs, rowNum) -> {
            TVOrder tvOrder = new TVOrder();
            tvOrder.setOrderId(rs.getInt("order_id"));
            tvOrder.setCustomerName(rs.getString("customer_name"));
            tvOrder.setOrderDate(rs.getDate("order_date").toLocalDate());
            tvOrder.setTotalAmount(rs.getDouble("total_amount"));
            return tvOrder;
        });
    }
}
```

### 9. **`ComputerOrderReader.java`**

```java
package com.example.batch.reader;

import com.example.batch.entity.ComputerOrder;
import org.springframework.batch.item.database.JdbcCursorItemReader;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import javax.sql.DataSource;

@Component
public class ComputerOrderReader extends JdbcCursorItemReader<ComputerOrder> {

    public ComputerOrderReader(DataSource dataSource, @Value("#{jobParameters['orderDate']}") String orderDate) {
        setDataSource(dataSource);
        setSql("SELECT order_id, customer_name, order_date, total_amount FROM computer_orders WHERE order_date = ?");
        setPreparedStatementSetter(ps -> ps.setString(1, orderDate));
        setRowMapper((rs, rowNum) -> {
            ComputerOrder computerOrder = new ComputerOrder();
            computerOrder.setOrderId(rs.getInt("order_id"));
            computerOrder.setCustomerName(rs.getString("customer_name"));
            computerOrder.setOrderDate(rs.getDate("order_date").toLocalDate());
            computerOrder.setTotalAmount(rs.getDouble("total_amount"));
            return computerOrder;
        });
    }
}
```

### 10. **`OrderItemWriter.java`**

```java
package com.example.batch.writer;

import com.example.batch.entity.Order;
import org.springframework.batch.item.file.FlatFileItemWriter;
import org.springframework.batch.item.file.transform.LineAggregator;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.FileSystemResource;
import org.springframework.stereotype.Component;

import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.List;

@Component
public class OrderItemWriter extends FlatFileItemWriter<Order> {

    private double totalAmount = 0.0;
    private int totalCount = 0;
    private final String outputFileName;

    public OrderItemWriter(@Value("#{jobParameters['orderDate']}") String orderDate) {
        this.outputFileName = "order-" + LocalDate.now().format(DateTimeFormatter.ISO_DATE) + ".csv";
        setResource(new FileSystemResource(outputFileName));
        setLineAggregator((LineAggregator<Order>) order -> String.format("%d,%s,%s,%.2f",
            order.getOrderId(),
            order.getCustomerName(),
            order.getOrderDate(),
            order.getTotalAmount()));
        setHeaderCallback(writer -> writer.write("Order ID,Customer Name,Order Date,Total Amount"));
        setFooterCallback(writer -> {
            writer.write("Total Records: " + totalCount + "\n");
            writer.write("Total Amount: " + totalAmount + "\n");
        });
    }

    @Override
    public void write(List<? extends Order> items) {
        for (Order item : items) {
            totalAmount += item.getTotalAmount();
            totalCount++;
        }
        super.write(items);
    }
}
```

### 11. **`TVOrderItemWriter.java`**

```java
package com.example.batch.writer;

import com.example.batch.entity.TVOrder;
import org.springframework.batch.item.file.FlatFileItemWriter;
import org.springframework.batch.item.file.transform.LineAggregator;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.FileSystemResource;
import org.springframework.stereotype.Component;

import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.List;

@Component
public class TVOrderItemWriter extends FlatFileItemWriter<TVOrder> {

    private double totalAmount = 0.0;
    private int totalCount = 0;
    private final String outputFileName;

    public TVOrderItemWriter(@Value("#{jobParameters['orderDate']}") String orderDate) {
        this.outputFileName = "tvorder-" + LocalDate.now().format(DateTimeFormatter.ISO_DATE) + ".csv";
        setResource(new FileSystemResource(outputFileName));
        setLineAggregator((LineAggregator<TVOrder>) tvOrder -> String.format("%d,%s,%s,%.2f",
            tvOrder.getOrderId(),
            tvOrder.getCustomerName(),
            tvOrder.getOrderDate(),
            tvOrder.getTotalAmount()));
        setHeaderCallback(writer -> writer.write("Order ID,Customer Name,Order Date,Total Amount"));
        setFooterCallback(writer -> {
            writer.write("Total Records: " + totalCount + "\n");
            writer.write("Total Amount: " + totalAmount + "\n");
        });
    }

    @Override
    public void write(List<? extends TVOrder> items) {
        for (TVOrder item : items) {
            totalAmount += item.getTotalAmount();
            totalCount++;
        }
        super.write(items);
    }
}
```

### 12. **`ComputerOrderItemWriter.java`**

```java
package com.example.batch.writer;

import com.example.batch.entity.ComputerOrder;
import org.springframework.batch.item.file.FlatFileItemWriter;
import org.springframework.batch.item.file.transform.LineAggregator;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.FileSystemResource;
import org.springframework.stereotype.Component;

import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.List;

@Component
public class ComputerOrderItemWriter extends FlatFileItemWriter<ComputerOrder> {

    private double totalAmount = 0.0;
    private int totalCount = 0;
    private final String outputFileName;

    public ComputerOrderItemWriter(@Value("#{jobParameters['orderDate']}") String orderDate) {
        this.outputFileName = "computerorder-" + LocalDate.now().format(DateTimeFormatter.ISO_DATE) + ".csv";
        setResource(new FileSystemResource(outputFileName));
        setLineAggregator((LineAggregator<ComputerOrder>) computerOrder -> String.format("%d,%s,%s,%.2f",
            computerOrder.getOrderId(),
            computerOrder.getCustomerName(),
            computerOrder.getOrderDate(),
            computerOrder.getTotalAmount()));
        setHeaderCallback(writer -> writer.write("Order ID,Customer Name,Order Date,Total Amount"));
        setFooterCallback(writer -> {
            writer.write("Total Records: " + totalCount + "\n");
            writer.write("Total Amount: " + totalAmount + "\n");
        });
    }

    @Override
    public void write(List<? extends ComputerOrder> items) {
        for (ComputerOrder item : items) {
            totalAmount += item.getTotalAmount();
            totalCount++;
        }
        super.write(items);
    }
}
```

### 13. **`ZipFileTasklet.java`**

```java
package com.example.batch.config;

import org.springframework.batch.core.StepContribution;
import org.springframework.batch.core.job.flow.support.state.TaskletStep;
import org.springframework.batch.core.step.tasklet.Tasklet;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.FileSystemResource;
import org.springframework.stereotype.Component;
import org.springframework.batch.repeat.RepeatStatus;

import java.io.*;
import java.nio.file.*;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

@Component
public class ZipFileTasklet implements Tasklet {

    @Value("#{jobExecutionContext['outputFileName']}")
    private String outputFileName;

    @Value("#{jobExecutionContext['totalAmount']}")
    private Double totalAmount;

    @Value("#{jobExecutionContext['totalCount']}")
    private Integer totalCount;

    @Override
    public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {
        Path filePath = Paths.get(outputFileName);
        Path zipPath = Paths.get(filePath.toString().replace(".csv", ".zip"));
        Path tagFilePath = Paths.get(filePath.toString().replace(".csv", "-tag.txt"));

        try (ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zipPath.toFile()));
             BufferedWriter tagFileWriter = Files.newBufferedWriter(tagFilePath, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {

            // Add the CSV file to the ZIP file
            try (FileInputStream fis = new FileInputStream(filePath.toFile())) {
                ZipEntry zipEntry = new ZipEntry(filePath.getFileName().toString());
                zos.putNextEntry(zipEntry);
                byte[] buffer = new byte[1024];
                int length;
                while ((length = fis.read(buffer)) > 0) {
                    zos.write(buffer, 0, length);
                }
                zos.closeEntry();
            }

            // Create the tag file
            tagFileWriter.write("Total Records: " + totalCount + "\n");
            tagFileWriter.write("Total Amount: " + totalAmount + "\n");
        }

        return RepeatStatus.FINISHED;
    }
}
```

### 14. **`JobCompletionListener.java`**

```java
package com.example.batch.listener;

import com.example.batch.writer.OrderItemWriter;
import com.example.batch.writer.TVOrderItemWriter;
import com.example.batch.writer.ComputerOrderItemWriter;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.JobExecutionListener;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class JobCompletionListener implements JobExecutionListener {

    @Autowired
    private OrderItemWriter orderItemWriter;

    @Autowired
    private TVOrderItemWriter tvOrderItemWriter;

    @Autowired
    private ComputerOrderItemWriter computerOrderItemWriter;

    @Override
    public void beforeJob(JobExecution jobExecution) {
        // No action needed before job starts
    }

    @Override
    public void afterJob(JobExecution jobExecution) {
        String jobName = jobExecution.getJobInstance().getJobName();
        if (jobName.equals("orderJob")) {
            jobExecution.getExecutionContext().put("outputFileName", orderItemWriter.getOutputFileName());
            jobExecution.getExecutionContext().put("totalAmount", orderItemWriter.getTotalAmount());
            jobExecution.getExecutionContext().put("totalCount", orderItemWriter.getTotalCount());
        } else if (jobName.equals("tvOrderJob")) {
            jobExecution.getExecutionContext().put("outputFileName", tvOrderItemWriter.getOutputFileName());
            jobExecution.getExecutionContext().put("totalAmount", tvOrderItemWriter.getTotalAmount());
            jobExecution.getExecutionContext().put("totalCount", tvOrderItemWriter.getTotalCount());
        } else if (jobName.equals("computerOrderJob")) {
            jobExecution.getExecutionContext().put("outputFileName", computerOrderItemWriter.getOutputFileName());
            jobExecution.getExecutionContext().put("totalAmount", computerOrderItemWriter.getTotalAmount());
            jobExecution.getExecutionContext().put("totalCount", computerOrderItemWriter.getTotalCount());
        }
        System.out.println("Job execution completed: " + jobName);
    }
}

```

### 15. **`application.properties`**

```properties
spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driver-class-name=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=password
spring.batch.job.enabled=false


```

### **Explanation**

- **Data Entities**: `Order`, `TVOrder`, and `ComputerOrder` represent the different types of orders.
- **Readers**: `OrderReader`, `TVOrderReader`, and `ComputerOrderReader` use `JdbcCursorItemReader` to read data from the database. Row mapping is done using lambda functions.
- **Processors**: `OrderProcessor` handles processing logic for all order types.
- **Writers**: `OrderItemWriter`, `TVOrderItemWriter`, and `ComputerOrderItemWriter` write data to CSV files, with specific implementations for each order type.
- **Jobs**: Configured for `Order`, `TVOrder`, and `ComputerOrder`, using the same processing and writing steps but with different readers and writers.
- **Tasklets**: `ZipFileTasklet` creates a ZIP file of the output CSV and a tag file.
- **Listeners**: `JobCompletionListener` logs the job completion.

This configuration ensures that each job type (Order, TVOrder, ComputerOrder) has its own job configuration but shares common processing logic, making the codebase clean and reusable.




ere is the complete project structure, including all Java classes necessary to handle `TVOrder` and `ComputerOrder` with separate jobs but leveraging code reuse and abstraction.

### **Project Structure**

```
src
└── main
    └── java
        └── com
            └── example
                └── batch
                    ├── BatchApplication.java
                    ├── config
                    │   ├── AbstractOrderJobConfig.java
                    │   ├── TVOrderJobConfig.java
                    │   ├── ComputerOrderJobConfig.java
                    │   └── ZipFileTasklet.java
                    ├── entity
                    │   ├── Order.java
                    │   ├── TVOrder.java
                    │   └── ComputerOrder.java
                    ├── listener
                    │   └── JobCompletionListener.java
                    ├── mapper
                    │   ├── OrderRowMapper.java
                    │   ├── TVOrderRowMapper.java
                    │   └── ComputerOrderRowMapper.java
                    ├── processor
                    │   └── OrderProcessor.java
                    ├── reader
                    │   ├── OrderReader.java
                    │   ├── TVOrderReader.java
                    │   └── ComputerOrderReader.java
                    └── writer
                        ├── OrderItemWriter.java
                        ├── TVOrderItemWriter.java
                        └── ComputerOrderItemWriter.java
```

### **1. `BatchApplication.java`**

```java
package com.example.batch;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class BatchApplication {
    public static void main(String[] args) {
        SpringApplication.run(BatchApplication.class, args);
    }
}
```

### **2. `config/AbstractOrderJobConfig.java**

```java
package com.example.batch.config;

import com.example.batch.processor.OrderProcessor;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.Step;
import org.springframework.batch.core.configuration.annotation.JobBuilderFactory;
import org.springframework.batch.core.configuration.annotation.StepBuilderFactory;
import org.springframework.batch.core.step.tasklet.Tasklet;
import org.springframework.batch.item.ItemProcessor;
import org.springframework.batch.item.ItemReader;
import org.springframework.batch.item.ItemWriter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public abstract class AbstractOrderJobConfig<T> {

    @Autowired
    protected JobBuilderFactory jobBuilderFactory;

    @Autowired
    protected StepBuilderFactory stepBuilderFactory;

    @Bean
    public abstract Job orderJob(Step processStep, Step zipStep);

    @Bean
    public abstract Step processStep();

    @Bean
    public abstract Step zipStep();

    protected Step processStep(ItemReader<T> reader, ItemProcessor<T, T> processor, ItemWriter<T> writer) {
        return stepBuilderFactory.get(getProcessStepName())
                .<T, T>chunk(10)
                .reader(reader)
                .processor(processor)
                .writer(writer)
                .build();
    }

    protected Step zipStep() {
        return stepBuilderFactory.get(getZipStepName())
                .tasklet(new ZipFileTasklet())
                .build();
    }

    protected abstract String getJobName();
    protected abstract String getProcessStepName();
    protected abstract String getZipStepName();
    protected abstract ItemReader<T> getOrderReader();
    protected abstract ItemWriter<T> getItemWriter();
}
```

### **3. `config/TVOrderJobConfig.java`**

```java
package com.example.batch.config;

import com.example.batch.entity.TVOrder;
import com.example.batch.writer.TVOrderItemWriter;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.Step;
import org.springframework.batch.core.configuration.annotation.EnableBatchProcessing;
import org.springframework.batch.core.configuration.annotation.JobBuilderFactory;
import org.springframework.batch.core.configuration.annotation.StepBuilderFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@EnableBatchProcessing
public class TVOrderJobConfig extends AbstractOrderJobConfig<TVOrder> {

    @Autowired
    private TVOrderReader tvOrderReader;

    @Autowired
    private TVOrderItemWriter tvOrderItemWriter;

    @Bean
    @Override
    public Job orderJob(Step processStep, Step zipStep) {
        return jobBuilderFactory.get(getJobName())
                .start(processStep)
                .next(zipStep)
                .build();
    }

    @Bean
    @Override
    public Step processStep() {
        return super.processStep(tvOrderReader, new OrderProcessor(), tvOrderItemWriter);
    }

    @Bean
    @Override
    public Step zipStep() {
        return super.zipStep();
    }

    @Override
    protected String getJobName() {
        return "tvOrderJob";
    }

    @Override
    protected String getProcessStepName() {
        return "tvOrderProcessStep";
    }

    @Override
    protected String getZipStepName() {
        return "tvOrderZipStep";
    }

    @Override
    protected TVOrderReader getOrderReader() {
        return tvOrderReader;
    }

    @Override
    protected TVOrderItemWriter getItemWriter() {
        return tvOrderItemWriter;
    }
}
```

### **4. `config/ComputerOrderJobConfig.java`**

```java
package com.example.batch.config;

import com.example.batch.entity.ComputerOrder;
import com.example.batch.writer.ComputerOrderItemWriter;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.Step;
import org.springframework.batch.core.configuration.annotation.EnableBatchProcessing;
import org.springframework.batch.core.configuration.annotation.JobBuilderFactory;
import org.springframework.batch.core.configuration.annotation.StepBuilderFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@EnableBatchProcessing
public class ComputerOrderJobConfig extends AbstractOrderJobConfig<ComputerOrder> {

    @Autowired
    private ComputerOrderReader computerOrderReader;

    @Autowired
    private ComputerOrderItemWriter computerOrderItemWriter;

    @Bean
    @Override
    public Job orderJob(Step processStep, Step zipStep) {
        return jobBuilderFactory.get(getJobName())
                .start(processStep)
                .next(zipStep)
                .build();
    }

    @Bean
    @Override
    public Step processStep() {
        return super.processStep(computerOrderReader, new OrderProcessor(), computerOrderItemWriter);
    }

    @Bean
    @Override
    public Step zipStep() {
        return super.zipStep();
    }

    @Override
    protected String getJobName() {
        return "computerOrderJob";
    }

    @Override
    protected String getProcessStepName() {
        return "computerOrderProcessStep";
    }

    @Override
    protected String getZipStepName() {
        return "computerOrderZipStep";
    }

    @Override
    protected ComputerOrderReader getOrderReader() {
        return computerOrderReader;
    }

    @Override
    protected ComputerOrderItemWriter getItemWriter() {
        return computerOrderItemWriter;
    }
}
```

### **5. `config/ZipFileTasklet.java`**

```java
package com.example.batch.config;

import org.springframework.batch.core.StepContribution;
import org.springframework.batch.core.job.flow.support.state.TaskletStep;
import org.springframework.batch.core.step.tasklet.Tasklet;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.FileSystemResource;
import org.springframework.stereotype.Component;
import org.springframework.batch.repeat.RepeatStatus;

import java.io.*;
import java.nio.file.*;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

@Component
public class ZipFileTasklet implements Tasklet {

    @Value("#{jobExecutionContext['outputFileName']}")
    private String outputFileName;

    @Value("#{jobExecutionContext['totalAmount']}")
    private Double totalAmount;

    @Value("#{jobExecutionContext['totalCount']}")
    private Integer totalCount;

    @Override
    public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {
        Path filePath = Paths.get(outputFileName);
        Path zipPath = Paths.get(filePath.toString().replace(".csv", ".zip"));
        Path tagFilePath = Paths.get(filePath.toString().replace(".csv", "-tag.txt"));

        try (ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zipPath.toFile()));
             BufferedWriter tagFileWriter = Files.newBufferedWriter(tagFilePath, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {

            // Add the CSV file to the ZIP file
            try (FileInputStream fis = new FileInputStream(filePath.toFile())) {
                ZipEntry zipEntry = new ZipEntry(filePath.getFileName().toString());
                zos.putNextEntry(zipEntry);
                byte[] buffer = new byte[1024];
                int length;
                while ((length = fis.read(buffer)) > 0) {
                    zos.write(buffer, 0, length);
                }
                zos.closeEntry();
            }

            // Create the tag file
            tagFileWriter.write("Total Records: " + totalCount + "\n");
            tagFileWriter.write("Total Amount: " + totalAmount + "\n");
        }

        return RepeatStatus.FINISHED;
    }
}
```

### **6. `entity/Order.java`**

```java
package com.example.batch.entity;

import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDate;

@Data
@NoArgsConstructor
public class Order {
    private int orderId;
    private String customerName;
    private LocalDate orderDate;
    private

 double amount;
}
```

### **7. `entity/TVOrder.java`**

```java
package com.example.batch.entity;

public class TVOrder extends Order {
    private String tvModel;

    // Getters and setters
}
```

### **8. `entity/ComputerOrder.java`**

```java
package com.example.batch.entity;

public class ComputerOrder extends Order {
    private String computerModel;

    // Getters and setters
}
```

### **9. `mapper/OrderRowMapper.java`**

```java
package com.example.batch.mapper;

import com.example.batch.entity.Order;
import org.springframework.jdbc.core.RowMapper;

import java.sql.ResultSet;
import java.sql.SQLException;

public abstract class OrderRowMapper<T extends Order> implements RowMapper<T> {

    @Override
    public T mapRow(ResultSet rs, int rowNum) throws SQLException {
        T order = createOrder();
        order.setOrderId(rs.getInt("order_id"));
        order.setCustomerName(rs.getString("customer_name"));
        order.setOrderDate(rs.getDate("order_date").toLocalDate());
        order.setAmount(rs.getDouble("amount"));
        mapAdditionalFields(rs, order);
        return order;
    }

    protected abstract T createOrder();
    protected abstract void mapAdditionalFields(ResultSet rs, T order) throws SQLException;
}
```

### **10. `mapper/TVOrderRowMapper.java`**

```java
package com.example.batch.mapper;

import com.example.batch.entity.TVOrder;
import org.springframework.stereotype.Component;

import java.sql.ResultSet;
import java.sql.SQLException;

@Component
public class TVOrderRowMapper extends OrderRowMapper<TVOrder> {

    @Override
    protected TVOrder createOrder() {
        return new TVOrder();
    }

    @Override
    protected void mapAdditionalFields(ResultSet rs, TVOrder order) throws SQLException {
        order.setTvModel(rs.getString("tv_model"));
    }
}
```

### **11. `mapper/ComputerOrderRowMapper.java`**

```java
package com.example.batch.mapper;

import com.example.batch.entity.ComputerOrder;
import org.springframework.stereotype.Component;

import java.sql.ResultSet;
import java.sql.SQLException;

@Component
public class ComputerOrderRowMapper extends OrderRowMapper<ComputerOrder> {

    @Override
    protected ComputerOrder createOrder() {
        return new ComputerOrder();
    }

    @Override
    protected void mapAdditionalFields(ResultSet rs, ComputerOrder order) throws SQLException {
        order.setComputerModel(rs.getString("computer_model"));
    }
}
```

### **12. `processor/OrderProcessor.java`**

```java
package com.example.batch.processor;

import com.example.batch.entity.Order;
import org.springframework.batch.item.ItemProcessor;
import org.springframework.stereotype.Component;

@Component
public class OrderProcessor implements ItemProcessor<Order, Order> {

    @Override
    public Order process(Order order) throws Exception {
        // Add custom processing logic if needed
        return order;
    }
}
```

### **13. `reader/OrderReader.java`**

```java
package com.example.batch.reader;

import com.example.batch.entity.Order;
import com.example.batch.mapper.OrderRowMapper;
import org.springframework.batch.item.database.JdbcCursorItemReader;
import org.springframework.stereotype.Component;

@Component
public abstract class OrderReader<T extends Order> extends JdbcCursorItemReader<T> {

    public OrderReader(String sql, OrderRowMapper<T> rowMapper) {
        super();
        setSql(sql);
        setRowMapper(rowMapper);
        setFetchSize(10);
    }
}
```

### **14. `reader/TVOrderReader.java`**

```java
package com.example.batch.reader;

import com.example.batch.entity.TVOrder;
import com.example.batch.mapper.TVOrderRowMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class TVOrderReader extends OrderReader<TVOrder> {

    @Autowired
    public TVOrderReader(TVOrderRowMapper rowMapper) {
        super("SELECT * FROM tv_orders", rowMapper);
    }
}
```

### **15. `reader/ComputerOrderReader.java`**

```java
package com.example.batch.reader;

import com.example.batch.entity.ComputerOrder;
import com.example.batch.mapper.ComputerOrderRowMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class ComputerOrderReader extends OrderReader<ComputerOrder> {

    @Autowired
    public ComputerOrderReader(ComputerOrderRowMapper rowMapper) {
        super("SELECT * FROM computer_orders", rowMapper);
    }
}
```

### **16. `writer/OrderItemWriter.java`**

```java
package com.example.batch.writer;

import com.example.batch.entity.Order;
import org.springframework.batch.item.ItemWriter;
import org.springframework.stereotype.Component;

import java.util.List;

@Component
public abstract class OrderItemWriter<T extends Order> implements ItemWriter<T> {

    @Override
    public void write(List<? extends T> items) throws Exception {
        // Default implementation can be overridden in specific writers
        for (T item : items) {
            writeItem(item);
        }
    }

    protected abstract void writeItem(T item) throws Exception;
}
```

### **17. `writer/TVOrderItemWriter.java`**

```java
package com.example.batch.writer;

import com.example.batch.entity.TVOrder;
import org.springframework.stereotype.Component;

@Component
public class TVOrderItemWriter extends OrderItemWriter<TVOrder> {

    @Override
    protected void writeItem(TVOrder item) throws Exception {
        // Implementation for writing TVOrder
        System.out.println("Writing TV Order: " + item);
    }
}
```

### **18. `writer/ComputerOrderItemWriter.java`**

```java
package com.example.batch.writer;

import com.example.batch.entity.ComputerOrder;
import org.springframework.stereotype.Component;

@Component
public class ComputerOrderItemWriter extends OrderItemWriter<ComputerOrder> {

    @Override
    protected void writeItem(ComputerOrder item) throws Exception {
        // Implementation for writing ComputerOrder
        System.out.println("Writing Computer Order: " + item);
    }
}
```

### **19. `listener/JobCompletionListener.java`**

```java
package com.example.batch.listener;

import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.JobExecutionListener;
import org.springframework.batch.core.annotation.AfterJob;
import org.springframework.batch.core.annotation.BeforeJob;
import org.springframework.stereotype.Component;

@Component
public class JobCompletionListener implements JobExecutionListener {

    @Override
    @BeforeJob
    public void beforeJob(JobExecution jobExecution) {
        System.out.println("Starting job: " + jobExecution.getJobInstance().getJobName());
    }

    @Override
    @AfterJob
    public void afterJob(JobExecution jobExecution) {
        System.out.println("Job completed with status: " + jobExecution.getStatus());
    }
}
```

### **20. `application.properties`**

```properties
spring.batch.job.enabled=false
```

This configuration should allow you to handle `TVOrder` and `ComputerOrder` types with separate jobs, but share common logic and configuration wherever possible to maximize code reuse and maintainability.

 public Step tvOrderStep() {
        return stepBuilderFactory.get("tvOrderStep")
                .<TVOrder, TVOrder>chunk(1000)
                .reader(tvOrderReader)
                .writer(new OrderItemWriter<>(
                        "tvOrders.csv",
                        tvOrderLineAggregator,
                        "Header for TV Orders",
                        "Trailer for TV Orders"
                ))
                .listener(tvOrderReadListener)
                .taskExecutor(taskExecutor())
                .build();
    }





-------------------- job executor --------------------------                    
                    Sure, here's a complete project structure for a Spring Batch application that processes TV and Computer orders. The project includes separate jobs and writers for TV and Computer orders, integration tests, and configurations.

### **1. Project Structure**

```
src/
├── main/
│   ├── java/
│   │   └── com/
│   │       └── example/
│   │           └── batch/
│   │               ├── config/
│   │               │   ├── BatchConfig.java
│   │               │   ├── DataSourceConfig.java
│   │               │   └── JobConfig.java
│   │               ├── entity/
│   │               │   ├── ComputerOrder.java
│   │               │   ├── Order.java
│   │               │   └── TVOrder.java
│   │               ├── job/
│   │               │   ├── ComputerOrderJob.java
│   │               │   ├── TVOrderJob.java
│   │               │   ├── ComputerOrderWriter.java
│   │               │   ├── TVOrderWriter.java
│   │               │   ├── ComputerOrderReader.java
│   │               │   ├── TVOrderReader.java
│   │               │   ├── ComputerOrderProcessor.java
│   │               │   └── TVOrderProcessor.java
│   │               ├── listener/
│   │               │   ├── ItemReadListener.java
│   │               │   └── JobCompletionNotificationListener.java
│   │               └── tasklet/
│   │                   └── CustomTasklet.java
│   ├── resources/
│   │   ├── application.properties
│   │   ├── application-test.properties
│   │   ├── schema.sql
│   │   ├── data.sql
│   │   └── logback.xml
│   └── test/
│       ├── java/
│       │   └── com/
│       │       └── example/
│       │           └── batch/
│       │               ├── JobIntegrationTest.java
│       │               ├── TVOrderJobIntegrationTest.java
│       │               └── ComputerOrderJobIntegrationTest.java
│       └── resources/
│           ├── application-test.properties
│           └── schema.sql
```

### **2. Code Files**

#### **BatchConfig.java**

```java
package com.example.batch.config;

import org.springframework.batch.core.configuration.annotation.EnableBatchProcessing;
import org.springframework.context.annotation.Configuration;

@Configuration
@EnableBatchProcessing
public class BatchConfig {
    // Define batch-related beans if needed
}
```

#### **DataSourceConfig.java**

```java
package com.example.batch.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.datasource.DriverManagerDataSource;

import javax.sql.DataSource;

@Configuration
public class DataSourceConfig {

    @Bean
    public DataSource dataSource() {
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName("org.h2.Driver");
        dataSource.setUrl("jdbc:h2:mem:testdb");
        dataSource.setUsername("sa");
        dataSource.setPassword("");
        return dataSource;
    }
}
```

#### **JobConfig.java**

```java
package com.example.batch.config;

import com.example.batch.job.ComputerOrderJob;
import com.example.batch.job.TVOrderJob;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.Step;
import org.springframework.batch.core.configuration.annotation.JobBuilderFactory;
import org.springframework.batch.core.configuration.annotation.StepBuilderFactory;
import org.springframework.batch.core.configuration.annotation.EnableBatchProcessing;
import org.springframework.batch.core.launch.support.RunIdIncrementer;
import org.springframework.batch.core.step.tasklet.TaskletStep;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.task.TaskExecutor;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;

@Configuration
@EnableBatchProcessing
public class JobConfig {

    @Bean
    public Job computerOrderJob(JobBuilderFactory jobBuilderFactory, Step computerOrderStep) {
        return jobBuilderFactory.get("computerOrderJob")
            .incrementer(new RunIdIncrementer())
            .flow(computerOrderStep)
            .end()
            .build();
    }

    @Bean
    public Job tvOrderJob(JobBuilderFactory jobBuilderFactory, Step tvOrderStep) {
        return jobBuilderFactory.get("tvOrderJob")
            .incrementer(new RunIdIncrementer())
            .flow(tvOrderStep)
            .end()
            .build();
    }

    @Bean
    public Step computerOrderStep(StepBuilderFactory stepBuilderFactory, ComputerOrderReader reader, ComputerOrderProcessor processor, ComputerOrderWriter writer, TaskExecutor taskExecutor) {
        return stepBuilderFactory.get("computerOrderStep")
            .<ComputerOrder, ComputerOrder>chunk(100)
            .reader(reader)
            .processor(processor)
            .writer(writer)
            .taskExecutor(taskExecutor)
            .build();
    }

    @Bean
    public Step tvOrderStep(StepBuilderFactory stepBuilderFactory, TVOrderReader reader, TVOrderProcessor processor, TVOrderWriter writer, TaskExecutor taskExecutor) {
        return stepBuilderFactory.get("tvOrderStep")
            .<TVOrder, TVOrder>chunk(100)
            .reader(reader)
            .processor(processor)
            .writer(writer)
            .taskExecutor(taskExecutor)
            .build();
    }

    @Bean
    public TaskExecutor taskExecutor() {
        ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor();
        taskExecutor.setCorePoolSize(5);
        taskExecutor.setMaxPoolSize(10);
        taskExecutor.setQueueCapacity(25);
        taskExecutor.setThreadNamePrefix("BatchExecutor-");
        taskExecutor.initialize();
        return taskExecutor;
    }
}
```

#### **Order.java**

```java
package com.example.batch.entity;

import java.time.LocalDate;

public class Order {
    private int orderId;
    private String customerName;
    private LocalDate orderDate;
    private double totalAmount;

    // Getters and Setters
}
```

#### **TVOrder.java**

```java
package com.example.batch.entity;

public class TVOrder extends Order {
    private String model;
    private String manufacturer;

    // Getters and Setters
}
```

#### **ComputerOrder.java**

```java
package com.example.batch.entity;

public class ComputerOrder extends Order {
    private String cpu;
    private String ram;

    // Getters and Setters
}
```

#### **ComputerOrderReader.java**

```java
package com.example.batch.job;

import com.example.batch.entity.ComputerOrder;
import org.springframework.batch.item.ItemReader;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.Statement;
import javax.sql.DataSource;

public class ComputerOrderReader implements ItemReader<ComputerOrder> {

    private final DataSource dataSource;

    public ComputerOrderReader(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    @Override
    public ComputerOrder read() throws Exception {
        try (Connection connection = dataSource.getConnection();
             Statement statement = connection.createStatement();
             ResultSet resultSet = statement.executeQuery("SELECT * FROM computer_orders")) {

            if (resultSet.next()) {
                ComputerOrder order = new ComputerOrder();
                order.setOrderId(resultSet.getInt("order_id"));
                order.setCustomerName(resultSet.getString("customer_name"));
                order.setOrderDate(resultSet.getDate("order_date").toLocalDate());
                order.setTotalAmount(resultSet.getDouble("total_amount"));
                order.setCpu(resultSet.getString("cpu"));
                order.setRam(resultSet.getString("ram"));
                return order;
            }
        }
        return null;
    }
}
```

#### **TVOrderReader.java**

```java
package com.example.batch.job;

import com.example.batch.entity.TVOrder;
import org.springframework.batch.item.ItemReader;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.Statement;
import javax.sql.DataSource;

public class TVOrderReader implements ItemReader<TVOrder> {

    private final DataSource dataSource;

    public TVOrderReader(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    @Override
    public TVOrder read() throws Exception {
        try (Connection connection = dataSource.getConnection();
             Statement statement = connection.createStatement();
             ResultSet resultSet = statement.executeQuery("SELECT * FROM tv_orders")) {

            if (resultSet.next()) {
                TVOrder order = new TVOrder();
                order.setOrderId(resultSet.getInt("order_id"));
                order.setCustomerName(resultSet.getString("customer_name"));
                order.setOrderDate(resultSet.getDate("order_date").toLocalDate());
                order.setTotalAmount(resultSet.getDouble("total_amount"));
                order.setModel(resultSet.getString("model"));
                order.setManufacturer(resultSet.getString("manufacturer"));
                return order;
            }
        }
        return null;
    }
}
```

#### **ComputerOrderProcessor.java**

```java
package com.example.batch.job;

import com.example.batch.entity.ComputerOrder;
import org.springframework.batch.item.ItemProcessor;

public class ComputerOrderProcessor implements ItemProcessor<ComputerOrder, ComputerOrder> {

    @Override
    public ComputerOrder process(ComputerOrder item) {
        // Process the computer order if needed
        return item;
    }
}
```

#### **TVOrderProcessor.java**

```java
package com.example.batch.job;

import com.example.batch.entity.TVOrder;
import org.springframework.batch.item.ItemProcessor;

public class TVOrderProcessor implements ItemProcessor<TV

Order, TVOrder> {

    @Override
    public TVOrder process(TVOrder item) {
        // Process the TV order if needed
        return item;
    }
}
```

#### **ComputerOrderWriter.java**

```java
package com.example.batch.job;

import com.example.batch.entity.ComputerOrder;
import org.springframework.batch.item.ItemWriter;

import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.List;

public class ComputerOrderWriter implements ItemWriter<ComputerOrder> {

    private final String outputFile;

    public ComputerOrderWriter(String outputFile) {
        this.outputFile = outputFile;
    }

    @Override
    public void write(List<? extends ComputerOrder> items) throws IOException {
        try (PrintWriter writer = new PrintWriter(new FileWriter(outputFile, true))) {
            for (ComputerOrder item : items) {
                writer.println(item.getOrderId() + "," +
                               item.getCustomerName() + "," +
                               item.getOrderDate() + "," +
                               item.getTotalAmount() + "," +
                               item.getCpu() + "," +
                               item.getRam());
            }
        }
    }
}
```

#### **TVOrderWriter.java**

```java
package com.example.batch.job;

import com.example.batch.entity.TVOrder;
import org.springframework.batch.item.ItemWriter;

import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.List;

public class TVOrderWriter implements ItemWriter<TVOrder> {

    private final String outputFile;

    public TVOrderWriter(String outputFile) {
        this.outputFile = outputFile;
    }

    @Override
    public void write(List<? extends TVOrder> items) throws IOException {
        try (PrintWriter writer = new PrintWriter(new FileWriter(outputFile, true))) {
            for (TVOrder item : items) {
                writer.println(item.getOrderId() + "," +
                               item.getCustomerName() + "," +
                               item.getOrderDate() + "," +
                               item.getTotalAmount() + "," +
                               item.getModel() + "," +
                               item.getManufacturer());
            }
        }
    }
}
```

#### **JobCompletionNotificationListener.java**

```java
package com.example.batch.listener;

import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.JobExecutionListener;
import org.springframework.stereotype.Component;

@Component
public class JobCompletionNotificationListener implements JobExecutionListener {

    @Override
    public void beforeJob(JobExecution jobExecution) {
        // Called before the job starts
    }

    @Override
    public void afterJob(JobExecution jobExecution) {
        // Called after the job ends
    }
}
```

#### **ItemReadListener.java**

```java
package com.example.batch.listener;

import org.springframework.batch.core.ItemReadListener;
import org.springframework.batch.item.ItemReadListener;
import org.springframework.stereotype.Component;

@Component
public class ItemReadListener<T> implements ItemReadListener<T> {

    @Override
    public void beforeRead() {
        // Called before reading an item
    }

    @Override
    public void afterRead(T item) {
        // Called after reading an item
    }

    @Override
    public void onReadError(Exception ex) {
        // Called when an error occurs while reading an item
    }
}
```

#### **ComputerOrderJob.java**

```java
package com.example.batch.job;

import org.springframework.batch.core.Job;
import org.springframework.batch.core.Step;
import org.springframework.batch.core.configuration.annotation.JobBuilderFactory;
import org.springframework.batch.core.configuration.annotation.StepBuilderFactory;
import org.springframework.batch.core.configuration.annotation.JobConfigurer;
import org.springframework.batch.core.step.tasklet.TaskletStep;
import org.springframework.batch.core.step.tasklet.TaskletStep;
import org.springframework.batch.core.step.tasklet.TaskletStep;
import org.springframework.batch.core.step.tasklet.TaskletStep;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class ComputerOrderJob {

    @Autowired
    private JobBuilderFactory jobBuilderFactory;

    @Autowired
    private StepBuilderFactory stepBuilderFactory;

    @Bean
    public Job computerOrderJob() {
        return jobBuilderFactory.get("computerOrderJob")
            .start(computerOrderStep())
            .build();
    }

    @Bean
    public Step computerOrderStep() {
        return stepBuilderFactory.get("computerOrderStep")
            .<ComputerOrder, ComputerOrder>chunk(100)
            .reader(new ComputerOrderReader())
            .processor(new ComputerOrderProcessor())
            .writer(new ComputerOrderWriter("computer_orders.csv"))
            .build();
    }
}
```

#### **TVOrderJob.java**

```java
package com.example.batch.job;

import org.springframework.batch.core.Job;
import org.springframework.batch.core.Step;
import org.springframework.batch.core.configuration.annotation.JobBuilderFactory;
import org.springframework.batch.core.configuration.annotation.StepBuilderFactory;
import org.springframework.batch.core.configuration.annotation.JobConfigurer;
import org.springframework.batch.core.step.tasklet.TaskletStep;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class TVOrderJob {

    @Autowired
    private JobBuilderFactory jobBuilderFactory;

    @Autowired
    private StepBuilderFactory stepBuilderFactory;

    @Bean
    public Job tvOrderJob() {
        return jobBuilderFactory.get("tvOrderJob")
            .start(tvOrderStep())
            .build();
    }

    @Bean
    public Step tvOrderStep() {
        return stepBuilderFactory.get("tvOrderStep")
            .<TVOrder, TVOrder>chunk(100)
            .reader(new TVOrderReader())
            .processor(new TVOrderProcessor())
            .writer(new TVOrderWriter("tv_orders.csv"))
            .build();
    }
}
```

### **4. Integration Tests**

#### **TVOrderJobIntegrationTest.java**

```java
package com.example.batch;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.JobParametersBuilder;
import org.springframework.batch.core.launch.JobLauncher;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.Statement;

import static org.junit.jupiter.api.Assertions.assertEquals;

@SpringBootTest
public class TVOrderJobIntegrationTest {

    @Autowired
    private JobLauncher jobLauncher;

    @Autowired
    private Job tvOrderJob;

    @Autowired
    private DataSource dataSource;

    @BeforeEach
    public void setUp() throws Exception {
        try (Connection connection = dataSource.getConnection();
             Statement statement = connection.createStatement()) {

            statement.execute("INSERT INTO tv_orders (order_id, customer_name, order_date, total_amount, model, manufacturer) VALUES (1, 'John Doe', '2024-07-31', 299.99, 'ModelX', 'BrandY')");
        }
    }

    @Test
    public void testTVOrderJob() throws Exception {
        JobExecution jobExecution = jobLauncher.run(tvOrderJob, new JobParametersBuilder()
            .addString("orderType", "TV")
            .toJobParameters());

        assertEquals("COMPLETED", jobExecution.getStatus().toString());

        // Verify output file or database entries

        try (Connection connection = dataSource.getConnection();
             Statement statement = connection.createStatement()) {

            statement.execute("DELETE FROM tv_orders WHERE order_id = 1");
        }
    }
}
```

#### **ComputerOrderJobIntegrationTest.java**

```java
package com.example.batch;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.JobParametersBuilder;
import org.springframework.batch.core.launch.JobLauncher;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.Statement;

import static org.junit.jupiter.api.Assertions.assertEquals;

@SpringBootTest
public class ComputerOrderJobIntegrationTest {

    @Autowired
    private JobLauncher jobLauncher;

    @Autowired
    private Job computerOrderJob;

    @Autowired
    private DataSource dataSource;

    @BeforeEach
    public void setUp() throws Exception {
        try (Connection connection = dataSource.getConnection();
             Statement statement = connection.createStatement()) {

            statement.execute("INSERT INTO computer_orders (order_id, customer_name, order_date, total_amount, cpu, ram) VALUES (2, 'Jane Smith', '2024-07-31', 999.99, 'Intel i7', '16GB')");
        }
    }

    @Test
    public void testComputerOrderJob() throws Exception {
        JobExecution jobExecution = jobLauncher.run(computerOrderJob, new JobParametersBuilder()
            .addString("orderType", "Computer")
            .toJobParameters());

        assertEquals("COMPLETED", jobExecution.getStatus().toString());

        // Verify output file or database entries

        try (Connection connection = dataSource.getConnection();
             Statement statement = connection.createStatement()) {

            statement.execute("DELETE FROM computer_orders WHERE order_id = 2");
        }
    }
}
```

### **5. Configuration Files**

#### **application.properties**

```properties
spring.batch.job.enabled=false
```

#### **application-test.properties**

```properties
spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driver-class-name=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=password
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
```

#### **schema.sql**

```sql
CREATE TABLE computer_orders (
    order_id INT PRIMARY KEY,
    customer_name VARCHAR(255),
    order_date DATE,
    total_amount DOUBLE

,
    cpu VARCHAR(255),
    ram VARCHAR(255)
);

CREATE TABLE tv_orders (
    order_id INT PRIMARY KEY,
    customer_name VARCHAR(255),
    order_date DATE,
    total_amount DOUBLE,
    model VARCHAR(255),
    manufacturer VARCHAR(255)
);
```

#### **data.sql**

```sql
-- Initial data can be added here if necessary
```

### **6. Dependencies**

Ensure your `pom.xml` or `build.gradle` includes the necessary dependencies for Spring Batch, H2 database, and testing libraries.

#### **pom.xml Example**

```xml
<dependencies>
    <!-- Spring Boot and Batch dependencies -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-batch</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jdbc</artifactId>
    </dependency>
    <dependency>
        <groupId>org.h2</groupId>
        <artifactId>h2</artifactId>
        <scope>runtime</scope>
    </dependency>
    <!-- Test dependencies -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
```

This setup ensures the project is modular, handles high volume efficiently with separate readers and writers, and includes integration tests for both TV and Computer orders.
